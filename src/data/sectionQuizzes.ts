export type QuizQuestionType = "single" | "multi" | "tf";

export interface QuizOption {
  id: string;
  text: string;
}

export interface QuizQuestion {
  id: string;
  type: QuizQuestionType;
  prompt: string;
  code?: string;
  options: QuizOption[];
  answer: string[]; // option ids
  explanation?: string;
}

export interface SectionQuiz {
  sectionId: string;
  title: string;
  passPercent: number; // 0-100
  questions: QuizQuestion[];
}

function tfOptions(): QuizOption[] {
  return [
    { id: "t", text: "正确" },
    { id: "f", text: "错误" },
  ];
}

export const sectionQuizzes: Record<string, SectionQuiz> = {
  intro: {
    sectionId: "intro",
    title: "Rust 简介 · 章节测验",
    passPercent: 90,
    questions: [
      {
        id: "intro-q1",
        type: "single",
        prompt: "Rust 的核心目标之一是：在不使用 GC 的情况下提供内存安全。",
        options: [
          { id: "a", text: "通过所有权系统在编译期保证" },
          { id: "b", text: "通过运行时垃圾回收保证" },
          { id: "c", text: "通过虚拟机隔离保证" },
          { id: "d", text: "通过手动 free 约定保证" },
        ],
        answer: ["a"],
      },
      {
        id: "intro-q2",
        type: "tf",
        prompt: "println! 是一个宏（macro）。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "intro-q3",
        type: "single",
        prompt: "Rust 官方的包管理与构建工具是：",
        options: [
          { id: "a", text: "pip" },
          { id: "b", text: "cargo" },
          { id: "c", text: "maven" },
          { id: "d", text: "gradle" },
        ],
        answer: ["b"],
      },
      {
        id: "intro-q4",
        type: "tf",
        prompt: "Rust 的变量默认是可变（mutable）的。",
        options: tfOptions(),
        answer: ["f"],
      },
      {
        id: "intro-q5",
        type: "single",
        prompt: "下面哪条命令最适合在开发期快速检查是否能通过编译（无需生成完整产物）？",
        options: [
          { id: "a", text: "cargo check" },
          { id: "b", text: "cargo doc" },
          { id: "c", text: "cargo clean" },
          { id: "d", text: "cargo install" },
        ],
        answer: ["a"],
      },
      {
        id: "intro-q6",
        type: "single",
        prompt: "Rust 1.0 发布于：",
        options: [
          { id: "a", text: "2012" },
          { id: "b", text: "2015" },
          { id: "c", text: "2018" },
          { id: "d", text: "2021" },
        ],
        answer: ["b"],
      },
      {
        id: "intro-q7",
        type: "tf",
        prompt: "Rust 支持零成本抽象（zero-cost abstractions）。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "intro-q8",
        type: "single",
        prompt: "Rust 通过哪种机制在编译期发现数据竞争（data race）？",
        options: [
          { id: "a", text: "借用检查与 Send/Sync 约束" },
          { id: "b", text: "运行时锁检测" },
          { id: "c", text: "GC 写屏障" },
          { id: "d", text: "JIT 编译分析" },
        ],
        answer: ["a"],
      },
      {
        id: "intro-q9",
        type: "single",
        prompt: "Rust 安装推荐使用的工具链管理器是：",
        options: [
          { id: "a", text: "brew" },
          { id: "b", text: "apt" },
          { id: "c", text: "rustup" },
          { id: "d", text: "choco" },
        ],
        answer: ["c"],
      },
      {
        id: "intro-q10",
        type: "tf",
        prompt: "Rust 程序的入口点通常是 main 函数。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "intro-q11",
        type: "single",
        prompt: "下面哪项最能描述“所有权转移（move）”？",
        options: [
          { id: "a", text: "两个变量同时拥有同一份可写数据" },
          { id: "b", text: "所有权从一个变量转给另一个变量，原变量失效" },
          { id: "c", text: "把引用的生命周期延长到 'static" },
          { id: "d", text: "把数据从堆复制到栈" },
        ],
        answer: ["b"],
      },
      {
        id: "intro-q12",
        type: "single",
        prompt: "下面哪个属于 Rust 安装后常见的工具？",
        options: [
          { id: "a", text: "clang-format" },
          { id: "b", text: "rustfmt" },
          { id: "c", text: "pipx" },
          { id: "d", text: "gradlew" },
        ],
        answer: ["b"],
      },
      {
        id: "intro-q13",
        type: "tf",
        prompt: "Rust 使用分号 `;` 结尾的通常是表达式（expression）。",
        options: tfOptions(),
        answer: ["f"],
        explanation: "带分号的一般是语句（statement）；表达式常作为返回值不带分号。",
      },
      {
        id: "intro-q14",
        type: "single",
        prompt: "Rust 的代码风格工具（lint）通常指的是：",
        options: [
          { id: "a", text: "clippy" },
          { id: "b", text: "valgrind" },
          { id: "c", text: "gdb" },
          { id: "d", text: "perf" },
        ],
        answer: ["a"],
      },
      {
        id: "intro-q15",
        type: "tf",
        prompt: "Rust 的宏调用通常以 `!` 结尾（如 println!）。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "intro-q16",
        type: "single",
        prompt: "Rust 的字符串字面量（\"hello\"）在类型上通常是：",
        options: [
          { id: "a", text: "String" },
          { id: "b", text: "&str" },
          { id: "c", text: "Vec<char>" },
          { id: "d", text: "CString" },
        ],
        answer: ["b"],
      },
      {
        id: "intro-q17",
        type: "tf",
        prompt: "Rust 的内存安全主要依赖运行时检查。",
        options: tfOptions(),
        answer: ["f"],
      },
      {
        id: "intro-q18",
        type: "single",
        prompt: "以下哪个更贴近 Rust 的并发哲学？",
        options: [
          { id: "a", text: "先写并发，出错再加锁" },
          { id: "b", text: "在编译期尽量捕获并发错误（fearless concurrency）" },
          { id: "c", text: "完全依赖运行时调度避免竞态" },
          { id: "d", text: "用 GC 消除并发内存问题" },
        ],
        answer: ["b"],
      },
      {
        id: "intro-q19",
        type: "tf",
        prompt: "Rust 的所有权系统可以帮助避免悬垂引用（dangling references）。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "intro-q20",
        type: "single",
        prompt: "想更新 Rust 工具链，最常用的命令是：",
        options: [
          { id: "a", text: "cargo update" },
          { id: "b", text: "rustup update" },
          { id: "c", text: "rustc update" },
          { id: "d", text: "cargo upgrade" },
        ],
        answer: ["b"],
      },
    ],
  },

  cargo: {
    sectionId: "cargo",
    title: "Cargo 与项目管理 · 章节测验",
    passPercent: 90,
    questions: [
      {
        id: "cargo-q1",
        type: "single",
        prompt: "创建一个二进制项目最常用的命令是：",
        options: [
          { id: "a", text: "cargo init --lib" },
          { id: "b", text: "cargo new my_app" },
          { id: "c", text: "rustup new my_app" },
          { id: "d", text: "cargo add my_app" },
        ],
        answer: ["b"],
      },
      { id: "cargo-q2", type: "tf", prompt: "Cargo.toml 用于描述包信息与依赖。", options: tfOptions(), answer: ["t"] },
      {
        id: "cargo-q3",
        type: "single",
        prompt: "以下哪个命令会以更严格的优化配置构建产物？",
        options: [
          { id: "a", text: "cargo build" },
          { id: "b", text: "cargo build --release" },
          { id: "c", text: "cargo check" },
          { id: "d", text: "cargo fmt" },
        ],
        answer: ["b"],
      },
      {
        id: "cargo-q4",
        type: "single",
        prompt: "在 workspace 中，通常只会有一个：",
        options: [
          { id: "a", text: "Cargo.lock（在 workspace 根目录）" },
          { id: "b", text: "src/main.rs（在 workspace 根目录）" },
          { id: "c", text: "target/（每个 crate 一个）" },
          { id: "d", text: "README（每个 crate 必须有）" },
        ],
        answer: ["a"],
      },
      { id: "cargo-q5", type: "tf", prompt: "cargo check 会生成可执行文件。", options: tfOptions(), answer: ["f"] },
      {
        id: "cargo-q6",
        type: "single",
        prompt: "以下哪项最贴近 features 的用途？",
        options: [
          { id: "a", text: "运行时动态加载模块" },
          { id: "b", text: "编译期按需启用可选能力" },
          { id: "c", text: "把依赖发布到 crates.io" },
          { id: "d", text: "生成 API 文档" },
        ],
        answer: ["b"],
      },
      {
        id: "cargo-q7",
        type: "tf",
        prompt: "可选依赖通常需要在 dependencies 中设置 optional = true。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "cargo-q8",
        type: "single",
        prompt: "下面哪个命令用于运行测试？",
        options: [
          { id: "a", text: "cargo test" },
          { id: "b", text: "cargo bench" },
          { id: "c", text: "cargo doc" },
          { id: "d", text: "cargo clean" },
        ],
        answer: ["a"],
      },
      {
        id: "cargo-q9",
        type: "single",
        prompt: "在 crate 之间进行本地联调时，最常见的依赖形式是：",
        options: [
          { id: "a", text: "{ git = \"...\" }" },
          { id: "b", text: "{ path = \"../other\" }" },
          { id: "c", text: "{ registry = \"...\" }" },
          { id: "d", text: "动态链接库 dlopen" },
        ],
        answer: ["b"],
      },
      { id: "cargo-q10", type: "tf", prompt: "cargo fmt 主要用于格式化代码。", options: tfOptions(), answer: ["t"] },
      {
        id: "cargo-q11",
        type: "single",
        prompt: "以下哪项属于 profile.release 中常见的优化选项？",
        options: [
          { id: "a", text: "lto = true" },
          { id: "b", text: "panic = \"unwind\"" },
          { id: "c", text: "edition = \"2021\"" },
          { id: "d", text: "resolver = \"2\"" },
        ],
        answer: ["a"],
      },
      { id: "cargo-q12", type: "tf", prompt: "Cargo 默认的 dev profile 通常更快编译、优化更少。", options: tfOptions(), answer: ["t"] },
      {
        id: "cargo-q13",
        type: "single",
        prompt: "要生成并打开文档，常用命令是：",
        options: [
          { id: "a", text: "cargo doc --open" },
          { id: "b", text: "cargo open --doc" },
          { id: "c", text: "cargo docs" },
          { id: "d", text: "cargo build --doc" },
        ],
        answer: ["a"],
      },
      {
        id: "cargo-q14",
        type: "tf",
        prompt: "在 main.rs 中写 `mod greet;` 会让编译器寻找同级的 greet.rs 或 greet/mod.rs。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "cargo-q15",
        type: "single",
        prompt: "下面哪个最可能是 workspace 根 Cargo.toml 中的字段？",
        options: [
          { id: "a", text: "[workspace]" },
          { id: "b", text: "[bin]" },
          { id: "c", text: "[executor]" },
          { id: "d", text: "[rust]" },
        ],
        answer: ["a"],
      },
      { id: "cargo-q16", type: "tf", prompt: "cargo clippy 属于编译器级别的额外 lint 检查工具。", options: tfOptions(), answer: ["t"] },
      {
        id: "cargo-q17",
        type: "single",
        prompt: "以下哪个命令最适合清理构建产物？",
        options: [
          { id: "a", text: "cargo clean" },
          { id: "b", text: "cargo purge" },
          { id: "c", text: "cargo reset" },
          { id: "d", text: "cargo rm target" },
        ],
        answer: ["a"],
      },
      { id: "cargo-q18", type: "tf", prompt: "workspace members 只能是二进制 crate，不能是库 crate。", options: tfOptions(), answer: ["f"] },
      {
        id: "cargo-q19",
        type: "single",
        prompt: "features 常与哪种机制配合做条件编译？",
        options: [
          { id: "a", text: "#[cfg(...)]" },
          { id: "b", text: "unsafe" },
          { id: "c", text: "match" },
          { id: "d", text: "lifetime" },
        ],
        answer: ["a"],
      },
      { id: "cargo-q20", type: "tf", prompt: "Cargo.lock 通常会被提交到版本库（应用/二进制项目尤甚）。", options: tfOptions(), answer: ["t"] },
    ],
  },

  basics: {
    sectionId: "basics",
    title: "基础语法 · 章节测验",
    passPercent: 90,
    questions: [
      {
        id: "basics-q1",
        type: "tf",
        prompt: "Rust 中 `let x = 1;` 声明的变量默认不可变。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "basics-q2",
        type: "single",
        prompt: "要声明可变变量，关键字是：",
        options: [
          { id: "a", text: "var" },
          { id: "b", text: "mut" },
          { id: "c", text: "ref" },
          { id: "d", text: "move" },
        ],
        answer: ["b"],
      },
      {
        id: "basics-q3",
        type: "tf",
        prompt: "常量 `const` 的值必须在编译期可确定。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "basics-q4",
        type: "single",
        prompt: "Rust 中最常用的整数类型通常是：",
        options: [
          { id: "a", text: "i8" },
          { id: "b", text: "i16" },
          { id: "c", text: "i32" },
          { id: "d", text: "i128" },
        ],
        answer: ["c"],
      },
      {
        id: "basics-q5",
        type: "single",
        prompt: "Rust 的默认浮点类型是：",
        options: [
          { id: "a", text: "f32" },
          { id: "b", text: "f64" },
          { id: "c", text: "float" },
          { id: "d", text: "double" },
        ],
        answer: ["b"],
      },
      {
        id: "basics-q6",
        type: "tf",
        prompt: "Rust 中 `char` 一定占 1 个字节。",
        options: tfOptions(),
        answer: ["f"],
        explanation: "Rust 的 char 是 Unicode 标量值，占 4 字节。",
      },
      {
        id: "basics-q7",
        type: "single",
        prompt: "以下哪项属于复合类型（compound type）？",
        options: [
          { id: "a", text: "i64" },
          { id: "b", text: "bool" },
          { id: "c", text: "tuple" },
          { id: "d", text: "char" },
        ],
        answer: ["c"],
      },
      {
        id: "basics-q8",
        type: "tf",
        prompt: "数组（array）的长度在编译期固定。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "basics-q9",
        type: "single",
        prompt: "函数返回值类型使用哪个符号声明？",
        options: [
          { id: "a", text: "=>" },
          { id: "b", text: "->" },
          { id: "c", text: ":" },
          { id: "d", text: "::" },
        ],
        answer: ["b"],
      },
      {
        id: "basics-q10",
        type: "tf",
        prompt: "Rust 函数体最后一个表达式（无分号）可作为返回值。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "basics-q11",
        type: "single",
        prompt: "以下哪项是“变量遮蔽（shadowing）”的特点？",
        options: [
          { id: "a", text: "同名变量重新绑定，可改变类型" },
          { id: "b", text: "同名变量共享同一个可变内存位置" },
          { id: "c", text: "同名变量会在运行时报错" },
          { id: "d", text: "同名变量只能用于全局变量" },
        ],
        answer: ["a"],
      },
      {
        id: "basics-q12",
        type: "single",
        prompt: "match 表达式要求分支必须：",
        options: [
          { id: "a", text: "只写一个分支即可" },
          { id: "b", text: "覆盖所有可能情况（穷尽）" },
          { id: "c", text: "每个分支必须 panic" },
          { id: "d", text: "只能匹配整数" },
        ],
        answer: ["b"],
      },
      {
        id: "basics-q13",
        type: "tf",
        prompt: "if 在 Rust 中也是表达式，可以赋值给变量。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "basics-q14",
        type: "single",
        prompt: "下面哪个循环会一直运行，直到显式 break？",
        options: [
          { id: "a", text: "for" },
          { id: "b", text: "while" },
          { id: "c", text: "loop" },
          { id: "d", text: "match" },
        ],
        answer: ["c"],
      },
      {
        id: "basics-q15",
        type: "tf",
        prompt: "Rust 的 break 可以带值，用于从 loop 返回一个值。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "basics-q16",
        type: "single",
        prompt: "表达式与语句的区别之一是：",
        options: [
          { id: "a", text: "表达式会计算并产生值" },
          { id: "b", text: "语句可以作为函数返回值" },
          { id: "c", text: "表达式必须以分号结尾" },
          { id: "d", text: "语句不能执行操作" },
        ],
        answer: ["a"],
      },
      {
        id: "basics-q17",
        type: "tf",
        prompt: "在 Rust 中，`{ let x = 1; x + 1 }` 这一块本身是一个表达式。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "basics-q18",
        type: "single",
        prompt: "以下哪项更适合动态增长的顺序集合？",
        options: [
          { id: "a", text: "array" },
          { id: "b", text: "tuple" },
          { id: "c", text: "Vec<T>" },
          { id: "d", text: "char" },
        ],
        answer: ["c"],
      },
      {
        id: "basics-q19",
        type: "tf",
        prompt: "Rust 是静态类型语言，编译时必须知道变量类型（可推断也算）。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "basics-q20",
        type: "single",
        prompt: "以下哪项是合法的字符字面量？",
        options: [
          { id: "a", text: "\"a\"" },
          { id: "b", text: "'a'" },
          { id: "c", text: "'ab'" },
          { id: "d", text: "\"中\"" },
        ],
        answer: ["b"],
      },
    ],
  },

  "error-handling": {
    sectionId: "error-handling",
    title: "错误处理 · 章节测验",
    passPercent: 90,
    questions: [
      {
        id: "err-q1",
        type: "single",
        prompt: "Rust 中可恢复错误通常使用哪种类型表达？",
        options: [
          { id: "a", text: "Option<T>" },
          { id: "b", text: "Result<T, E>" },
          { id: "c", text: "panic!" },
          { id: "d", text: "Exception" },
        ],
        answer: ["b"],
      },
      { id: "err-q2", type: "tf", prompt: "panic! 一般用于不可恢复错误（bug）。", options: tfOptions(), answer: ["t"] },
      {
        id: "err-q3",
        type: "single",
        prompt: "对 Result 调用 unwrap() 在遇到 Err 时会：",
        options: [
          { id: "a", text: "返回默认值" },
          { id: "b", text: "返回 Option::None" },
          { id: "c", text: "panic" },
          { id: "d", text: "自动重试" },
        ],
        answer: ["c"],
      },
      { id: "err-q4", type: "tf", prompt: "expect() 可以提供自定义 panic 信息。", options: tfOptions(), answer: ["t"] },
      {
        id: "err-q5",
        type: "single",
        prompt: "`?` 运算符最贴近的作用是：",
        options: [
          { id: "a", text: "把 Result 转为 Option" },
          { id: "b", text: "如果是 Err 则提前返回 Err，否则解包 Ok" },
          { id: "c", text: "忽略错误继续执行" },
          { id: "d", text: "捕获 panic" },
        ],
        answer: ["b"],
      },
      {
        id: "err-q6",
        type: "tf",
        prompt: "`?` 只能用于 Result，不能用于 Option。",
        options: tfOptions(),
        answer: ["f"],
        explanation: "`?` 也能用于 Option（在返回 Option 的函数中）。",
      },
      {
        id: "err-q7",
        type: "single",
        prompt: "错误传播要求函数返回类型与 `?` 的错误类型：",
        options: [
          { id: "a", text: "完全无关" },
          { id: "b", text: "可通过 From/Into 转换或一致" },
          { id: "c", text: "必须是 panic" },
          { id: "d", text: "必须是 String" },
        ],
        answer: ["b"],
      },
      {
        id: "err-q8",
        type: "single",
        prompt: "下面哪个更像“用 match 手动处理错误”的写法？",
        options: [
          { id: "a", text: "let f = File::open(x)?;" },
          { id: "b", text: "let f = File::open(x).unwrap();" },
          { id: "c", text: "let f = match File::open(x) { Ok(f)=>f, Err(e)=>return Err(e) };" },
          { id: "d", text: "let f = File::open(x).ok();" },
        ],
        answer: ["c"],
      },
      { id: "err-q9", type: "tf", prompt: "Option 表示“可能缺失的值”，不携带错误信息。", options: tfOptions(), answer: ["t"] },
      {
        id: "err-q10",
        type: "single",
        prompt: "如果你希望把底层错误类型统一抽象为一个应用级错误，常见做法是：",
        options: [
          { id: "a", text: "把所有错误都 panic" },
          { id: "b", text: "定义 enum Error，并实现 From/Display 等" },
          { id: "c", text: "把所有错误转为 bool" },
          { id: "d", text: "忽略错误" },
        ],
        answer: ["b"],
      },
      { id: "err-q11", type: "tf", prompt: "使用 ? 能减少样板代码，使错误处理更“显式但不啰嗦”。", options: tfOptions(), answer: ["t"] },
      {
        id: "err-q12",
        type: "single",
        prompt: "从文件读取用户名并返回 Result<String, io::Error> 时，打开文件失败应该：",
        options: [
          { id: "a", text: "返回 Ok(\"\")" },
          { id: "b", text: "panic!" },
          { id: "c", text: "返回 Err(io::Error)" },
          { id: "d", text: "无限重试" },
        ],
        answer: ["c"],
      },
      { id: "err-q13", type: "tf", prompt: "不可恢复错误通常表示程序存在 bug，应尽早暴露。", options: tfOptions(), answer: ["t"] },
      {
        id: "err-q14",
        type: "single",
        prompt: "当你只关心“有没有值”，不关心错误细节时，以下更合适的是：",
        options: [
          { id: "a", text: "Result<T, E>" },
          { id: "b", text: "Option<T>" },
          { id: "c", text: "panic!" },
          { id: "d", text: "static mut" },
        ],
        answer: ["b"],
      },
      { id: "err-q15", type: "tf", prompt: "match 可以同时处理 Ok 与 Err 分支。", options: tfOptions(), answer: ["t"] },
      {
        id: "err-q16",
        type: "single",
        prompt: "下面哪个是“错误链路（cause）”常见需求？",
        options: [
          { id: "a", text: "让错误更短" },
          { id: "b", text: "保留底层错误信息，便于定位问题" },
          { id: "c", text: "让编译更快" },
          { id: "d", text: "避免所有权移动" },
        ],
        answer: ["b"],
      },
      { id: "err-q17", type: "tf", prompt: "Rust 没有传统意义的异常（exception）机制。", options: tfOptions(), answer: ["t"] },
      {
        id: "err-q18",
        type: "single",
        prompt: "下面哪个更贴近“把 Option 转为 Result 并附带错误信息”？",
        options: [
          { id: "a", text: "opt.unwrap()" },
          { id: "b", text: "opt.ok_or(\"missing\")" },
          { id: "c", text: "opt.expect(\"missing\")" },
          { id: "d", text: "opt.take()" },
        ],
        answer: ["b"],
      },
      { id: "err-q19", type: "tf", prompt: "使用 expect 比 unwrap 更适合生产代码，因为它能带上下文。", options: tfOptions(), answer: ["t"] },
      {
        id: "err-q20",
        type: "single",
        prompt: "下面哪项是错误处理的好实践？",
        options: [
          { id: "a", text: "所有函数都返回 String" },
          { id: "b", text: "为错误添加上下文，并区分可恢复/不可恢复" },
          { id: "c", text: "遇错就吞掉，保证程序继续跑" },
          { id: "d", text: "用 static mut 保存最后一次错误" },
        ],
        answer: ["b"],
      },
    ],
  },

  "practice-cli": {
    sectionId: "practice-cli",
    title: "实战：CLI 文本搜索器 · 章节测验",
    passPercent: 90,
    questions: [
      {
        id: "cli-q1",
        type: "single",
        prompt: "为了让核心逻辑更容易测试，推荐把搜索逻辑放在：",
        options: [
          { id: "a", text: "main.rs 里直接读取文件并处理" },
          { id: "b", text: "lib.rs 的纯函数中，由 main.rs 调用" },
          { id: "c", text: "build.rs 里生成代码" },
          { id: "d", text: "Cargo.toml 的 [profile] 中" },
        ],
        answer: ["b"],
      },
      {
        id: "cli-q2",
        type: "tf",
        prompt: "命令行参数解析手写 argv 通常比使用成熟库更可维护。",
        options: tfOptions(),
        answer: ["f"],
      },
      {
        id: "cli-q3",
        type: "single",
        prompt: "clap 的常见使用方式之一是：",
        options: [
          { id: "a", text: "用 derive 派生 Parser，把参数映射到结构体" },
          { id: "b", text: "用宏在运行时动态生成参数表" },
          { id: "c", text: "只能解析 JSON 配置文件" },
          { id: "d", text: "必须写 XML 描述文件" },
        ],
        answer: ["a"],
      },
      {
        id: "cli-q4",
        type: "tf",
        prompt: "错误信息建议输出到 stderr（例如 eprintln!）。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "cli-q5",
        type: "single",
        prompt: "当文件读取失败时，CLI 工具通常应该：",
        options: [
          { id: "a", text: "返回 0 退出码，静默失败" },
          { id: "b", text: "panic 并打印 backtrace" },
          { id: "c", text: "打印友好错误并返回非 0 退出码" },
          { id: "d", text: "无限重试直到成功" },
        ],
        answer: ["c"],
      },
      {
        id: "cli-q6",
        type: "tf",
        prompt: "把 IO 与纯逻辑分离，可以让单元测试更快更稳定。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "cli-q7",
        type: "single",
        prompt: "以下哪项最适合用于大小写不敏感搜索的最小实现？",
        options: [
          { id: "a", text: "对 query 和 line 都做 to_lowercase 后 contains" },
          { id: "b", text: "把文件转换成二进制再搜索" },
          { id: "c", text: "用 unsafe 指针遍历内存" },
          { id: "d", text: "用 GC 统一管理字符串" },
        ],
        answer: ["a"],
      },
      {
        id: "cli-q8",
        type: "tf",
        prompt: "返回 Vec<&str> 需要关注生命周期，因为它引用了输入内容。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "cli-q9",
        type: "single",
        prompt: "下面哪个命令最适合保证提交前代码格式一致？",
        options: [
          { id: "a", text: "cargo fmt" },
          { id: "b", text: "cargo doc" },
          { id: "c", text: "cargo clean" },
          { id: "d", text: "cargo update" },
        ],
        answer: ["a"],
      },
      {
        id: "cli-q10",
        type: "tf",
        prompt: "clippy 的建议可以帮助发现潜在 bug 与坏味道。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "cli-q11",
        type: "single",
        prompt: "集成测试通常放在：",
        options: [
          { id: "a", text: "src/tests.rs" },
          { id: "b", text: "tests/ 目录下" },
          { id: "c", text: "target/tests/ 下" },
          { id: "d", text: "Cargo.lock 里" },
        ],
        answer: ["b"],
      },
      {
        id: "cli-q12",
        type: "tf",
        prompt: "集成测试更强调通过 public API 驱动整体行为。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "cli-q13",
        type: "single",
        prompt: "当没有匹配行时，是否返回非 0 退出码最合理的答案是：",
        options: [
          { id: "a", text: "必须返回 2" },
          { id: "b", text: "必须返回 1" },
          { id: "c", text: "取决于你对“无匹配”语义的定义与文档约定" },
          { id: "d", text: "必须 panic" },
        ],
        answer: ["c"],
      },
      {
        id: "cli-q14",
        type: "tf",
        prompt: "main.rs 里直接写大量业务逻辑，会让测试和复用变困难。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "cli-q15",
        type: "single",
        prompt: "下面哪个更贴近“让错误上下文更清晰”的实践？",
        options: [
          { id: "a", text: "把所有错误转成空字符串" },
          { id: "b", text: "遇错就 unwrap()" },
          { id: "c", text: "打印带前缀的错误，并保留底层错误信息" },
          { id: "d", text: "忽略错误继续输出" },
        ],
        answer: ["c"],
      },
      {
        id: "cli-q16",
        type: "tf",
        prompt: "在 CLI 工具里，标准输出（stdout）通常用于正常结果，stderr 用于错误与诊断。",
        options: tfOptions(),
        answer: ["t"],
      },
      {
        id: "cli-q17",
        type: "single",
        prompt: "如果你把搜索函数写成 `fn search<'a>(... contents: &'a str) -> Vec<&'a str>`，它的含义是：",
        options: [
          { id: "a", text: "返回的引用至少和 contents 一样长" },
          { id: "b", text: "返回值与 contents 无关" },
          { id: "c", text: "返回值一定是 'static" },
          { id: "d", text: "返回值只能活 1 秒" },
        ],
        answer: ["a"],
      },
      {
        id: "cli-q18",
        type: "tf",
        prompt: "为了性能，任何时候都应该优先用 unsafe 来实现字符串匹配。",
        options: tfOptions(),
        answer: ["f"],
      },
      {
        id: "cli-q19",
        type: "single",
        prompt: "为 CLI 增加 `--ignore-case` 最自然的实现路径是：",
        options: [
          { id: "a", text: "先加参数，再在核心 search 函数中增加开关" },
          { id: "b", text: "只改 README，不改代码" },
          { id: "c", text: "把所有输入转换成 bytes 并丢弃 Unicode" },
          { id: "d", text: "删除大小写敏感功能" },
        ],
        answer: ["a"],
      },
      {
        id: "cli-q20",
        type: "tf",
        prompt: "写完 mini-rg 后，最推荐的发布前检查组合之一是：fmt + clippy + test。",
        options: tfOptions(),
        answer: ["t"],
      },
    ],
  },

  "practice-web": {
    sectionId: "practice-web",
    title: "实战：Web API（axum）· 章节测验",
    passPercent: 90,
    questions: [
      {
        id: "web-q1",
        type: "single",
        prompt: "axum 项目通常依赖哪个异步运行时？",
        options: [
          { id: "a", text: "tokio" },
          { id: "b", text: "goroutine" },
          { id: "c", text: "JVM" },
          { id: "d", text: "celery" },
        ],
        answer: ["a"],
      },
      { id: "web-q2", type: "tf", prompt: "Web handler 通常会被声明为 async fn。", options: tfOptions(), answer: ["t"] },
      {
        id: "web-q3",
        type: "single",
        prompt: "在 axum 中把状态注入到 handler 的常见方式是：",
        options: [
          { id: "a", text: "全局 static mut" },
          { id: "b", text: "Router::with_state + extract::State" },
          { id: "c", text: "宏展开替换代码" },
          { id: "d", text: "在 build.rs 中写入状态" },
        ],
        answer: ["b"],
      },
      { id: "web-q4", type: "tf", prompt: "在持有 Mutex 锁期间执行 .await 可能带来性能或死锁风险。", options: tfOptions(), answer: ["t"] },
      {
        id: "web-q5",
        type: "single",
        prompt: "返回 JSON 的常见组合是：",
        options: [
          { id: "a", text: "serde::Serialize + axum::Json<T>" },
          { id: "b", text: "println! + String" },
          { id: "c", text: "Vec<u8> + unsafe" },
          { id: "d", text: "Rc<RefCell<T>>" },
        ],
        answer: ["a"],
      },
      { id: "web-q6", type: "tf", prompt: "对外错误信息应该稳定、可预期，避免泄露敏感细节。", options: tfOptions(), answer: ["t"] },
      {
        id: "web-q7",
        type: "single",
        prompt: "把自定义错误映射成 HTTP 响应常用的 trait 是：",
        options: [
          { id: "a", text: "Iterator" },
          { id: "b", text: "IntoResponse" },
          { id: "c", text: "Deref" },
          { id: "d", text: "Drop" },
        ],
        answer: ["b"],
      },
      { id: "web-q8", type: "tf", prompt: "最小可运行的服务也应该有健康检查端点（例如 /healthz）。", options: tfOptions(), answer: ["t"] },
      {
        id: "web-q9",
        type: "single",
        prompt: "为了在 CI 中快速测试 Router，推荐的测试方式是：",
        options: [
          { id: "a", text: "必须真实监听端口并发起 HTTP 请求" },
          { id: "b", text: "把 Router 当成 Service，构造请求并断言响应" },
          { id: "c", text: "只测 main 函数是否编译" },
          { id: "d", text: "只测 HTML 页面" },
        ],
        answer: ["b"],
      },
      { id: "web-q10", type: "tf", prompt: "Web 项目不需要日志，靠 println! 就够了。", options: tfOptions(), answer: ["f"] },
      {
        id: "web-q11",
        type: "single",
        prompt: "以下哪个更适合用于结构化日志（工程常用）？",
        options: [
          { id: "a", text: "tracing" },
          { id: "b", text: "rand" },
          { id: "c", text: "regex" },
          { id: "d", text: "serde_yaml" },
        ],
        answer: ["a"],
      },
      { id: "web-q12", type: "tf", prompt: "绑定 127.0.0.1 比 0.0.0.0 更安全（默认只本机可访问）。", options: tfOptions(), answer: ["t"] },
      {
        id: "web-q13",
        type: "single",
        prompt: "下面哪项是良好的错误处理策略？",
        options: [
          { id: "a", text: "所有错误都返回 200" },
          { id: "b", text: "把错误统一映射为合理的状态码，并记录上下文" },
          { id: "c", text: "把内部错误细节原样返回给客户端" },
          { id: "d", text: "遇错就进程退出" },
        ],
        answer: ["b"],
      },
      { id: "web-q14", type: "tf", prompt: "serde 的 derive 常用于 JSON 的序列化/反序列化。", options: tfOptions(), answer: ["t"] },
      {
        id: "web-q15",
        type: "single",
        prompt: "将共享状态跨线程共享，最常见的手段之一是：",
        options: [
          { id: "a", text: "Arc<T>" },
          { id: "b", text: "Rc<T>" },
          { id: "c", text: "&mut T" },
          { id: "d", text: "static mut T" },
        ],
        answer: ["a"],
      },
      { id: "web-q16", type: "tf", prompt: "真实 Web 服务通常需要超时机制，避免请求无限等待。", options: tfOptions(), answer: ["t"] },
      {
        id: "web-q17",
        type: "single",
        prompt: "下面哪个更适合作为健康检查的返回？",
        options: [
          { id: "a", text: "Json<{ok: true}>" },
          { id: "b", text: "随机字符串" },
          { id: "c", text: "panic!" },
          { id: "d", text: "把数据库全表扫描一遍" },
        ],
        answer: ["a"],
      },
      { id: "web-q18", type: "tf", prompt: "把应用状态放进全局变量通常会增加耦合与测试成本。", options: tfOptions(), answer: ["t"] },
      {
        id: "web-q19",
        type: "single",
        prompt: "为了让 handler 更易维护，推荐：",
        options: [
          { id: "a", text: "所有逻辑都写在一个 handler 中" },
          { id: "b", text: "将业务逻辑抽到独立模块/服务层，handler 负责组合与转换" },
          { id: "c", text: "大量使用 unsafe" },
          { id: "d", text: "把所有状态都放在 Mutex 中" },
        ],
        answer: ["b"],
      },
      { id: "web-q20", type: "tf", prompt: "对外 API 的返回结构一旦发布，应尽量保持向后兼容。", options: tfOptions(), answer: ["t"] },
    ],
  },

  style: {
    sectionId: "style",
    title: "代码风格与工程结构 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "style-q1", type: "tf", prompt: "rustfmt 的目标之一是让代码格式统一，减少风格争论。", options: tfOptions(), answer: ["t"] },
      {
        id: "style-q2",
        type: "single",
        prompt: "让 clippy 警告在 CI 中变成错误的常见参数是：",
        options: [
          { id: "a", text: "cargo clippy -- -D warnings" },
          { id: "b", text: "cargo clippy --allow warnings" },
          { id: "c", text: "cargo clippy --fix-only" },
          { id: "d", text: "cargo clippy --no-lints" },
        ],
        answer: ["a"],
      },
      { id: "style-q3", type: "tf", prompt: "默认私有、按需 pub，是 Rust 工程中常见的可维护策略。", options: tfOptions(), answer: ["t"] },
      {
        id: "style-q4",
        type: "single",
        prompt: "newtype（例如 struct UserId(String)）常用于：",
        options: [
          { id: "a", text: "让编译更慢" },
          { id: "b", text: "表达业务约束，避免裸类型滥用" },
          { id: "c", text: "绕过借用检查" },
          { id: "d", text: "实现 GC" },
        ],
        answer: ["b"],
      },
      { id: "style-q5", type: "tf", prompt: "把 IO 边界推到更外层，核心逻辑会更容易测试。", options: tfOptions(), answer: ["t"] },
      {
        id: "style-q6",
        type: "single",
        prompt: "大型项目用多个 crate 分层的主要目的之一是：",
        options: [
          { id: "a", text: "让依赖方向清晰，避免相互引用" },
          { id: "b", text: "让代码更难找到" },
          { id: "c", text: "强制所有函数都 async" },
          { id: "d", text: "绕过模块系统限制" },
        ],
        answer: ["a"],
      },
      { id: "style-q7", type: "tf", prompt: "对外错误信息应尽量稳定，不暴露内部实现细节。", options: tfOptions(), answer: ["t"] },
      {
        id: "style-q8",
        type: "single",
        prompt: "thiserror 更常用于哪类场景？",
        options: [
          { id: "a", text: "库（library）定义结构化错误类型" },
          { id: "b", text: "前端页面布局" },
          { id: "c", text: "图像处理" },
          { id: "d", text: "随机数生成" },
        ],
        answer: ["a"],
      },
      {
        id: "style-q9",
        type: "single",
        prompt: "anyhow 更常用于哪类场景？",
        options: [
          { id: "a", text: "应用（application）把多种错误统一兜底并加上下文" },
          { id: "b", text: "替代 borrow checker" },
          { id: "c", text: "替代 clippy" },
          { id: "d", text: "替代 cargo" },
        ],
        answer: ["a"],
      },
      { id: "style-q10", type: "tf", prompt: "把工具检查（fmt/clippy/test）放进 CI 是一种常见的工程门禁。", options: tfOptions(), answer: ["t"] },
      {
        id: "style-q11",
        type: "single",
        prompt: "下面哪项更贴近“好评审”的关注点？",
        options: [
          { id: "a", text: "空格是 2 还是 4" },
          { id: "b", text: "边界、命名、可读性、错误模型与测试覆盖" },
          { id: "c", text: "是否用了一行最短的写法" },
          { id: "d", text: "是否用了尽可能多的宏" },
        ],
        answer: ["b"],
      },
      { id: "style-q12", type: "tf", prompt: "把业务约束编码进类型系统，通常能减少运行时检查。", options: tfOptions(), answer: ["t"] },
      {
        id: "style-q13",
        type: "single",
        prompt: "当一个模块内部实现复杂，但对外只需要少量函数时，推荐：",
        options: [
          { id: "a", text: "把所有函数都 pub" },
          { id: "b", text: "只暴露必要 pub API，其余保持私有" },
          { id: "c", text: "把所有东西写进一个文件" },
          { id: "d", text: "全部放进 unsafe" },
        ],
        answer: ["b"],
      },
      { id: "style-q14", type: "tf", prompt: "Rust 的模块系统能帮助你控制可见性与依赖方向。", options: tfOptions(), answer: ["t"] },
      {
        id: "style-q15",
        type: "single",
        prompt: "以下哪个更符合“分层”的依赖关系？",
        options: [
          { id: "a", text: "core 依赖 app" },
          { id: "b", text: "app 依赖 core" },
          { id: "c", text: "所有 crate 相互依赖" },
          { id: "d", text: "依赖方向随时变化" },
        ],
        answer: ["b"],
      },
      { id: "style-q16", type: "tf", prompt: "格式化与 lint 应该尽量自动化，减少团队内风格摩擦。", options: tfOptions(), answer: ["t"] },
      {
        id: "style-q17",
        type: "single",
        prompt: "下面哪项是“核心逻辑可测试”的典型信号？",
        options: [
          { id: "a", text: "函数到处读写全局变量" },
          { id: "b", text: "大部分逻辑是纯函数/可注入依赖，IO 在边界层" },
          { id: "c", text: "所有函数都打印日志" },
          { id: "d", text: "所有函数都返回 String" },
        ],
        answer: ["b"],
      },
      { id: "style-q18", type: "tf", prompt: "为了减少耦合，应该避免在多个模块之间共享可变全局状态。", options: tfOptions(), answer: ["t"] },
      {
        id: "style-q19",
        type: "single",
        prompt: "以下哪个更像“对外 API 的契约”？",
        options: [
          { id: "a", text: "pub 函数签名与文档、错误类型" },
          { id: "b", text: "内部私有 helper 函数" },
          { id: "c", text: "临时调试日志" },
          { id: "d", text: "target 目录内容" },
        ],
        answer: ["a"],
      },
      { id: "style-q20", type: "tf", prompt: "好的工程结构能让新成员更快定位代码与理解边界。", options: tfOptions(), answer: ["t"] },
    ],
  },

  ownership: {
    sectionId: "ownership",
    title: "所有权系统 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "own-q1", type: "tf", prompt: "Rust 中每个值都有且只有一个所有者（owner）。", options: tfOptions(), answer: ["t"] },
      {
        id: "own-q2",
        type: "single",
        prompt: "下面哪项属于所有权规则？",
        options: [
          { id: "a", text: "一个值可以同时有多个可变所有者" },
          { id: "b", text: "当所有者离开作用域时，值会被 drop" },
          { id: "c", text: "值永远不会被释放" },
          { id: "d", text: "引用可以比被引用值活得更久" },
        ],
        answer: ["b"],
      },
      { id: "own-q3", type: "tf", prompt: "把 String 赋值给另一个变量通常会发生 move。", options: tfOptions(), answer: ["t"] },
      {
        id: "own-q4",
        type: "single",
        prompt: "哪类类型通常实现 Copy（赋值不会 move）？",
        options: [
          { id: "a", text: "String" },
          { id: "b", text: "Vec<i32>" },
          { id: "c", text: "i32" },
          { id: "d", text: "HashMap<String, i32>" },
        ],
        answer: ["c"],
      },
      { id: "own-q5", type: "tf", prompt: "调用 clone() 会显式进行深拷贝（对拥有堆数据的类型很常见）。", options: tfOptions(), answer: ["t"] },
      {
        id: "own-q6",
        type: "single",
        prompt: "借用（borrowing）通常通过什么实现？",
        options: [
          { id: "a", text: "引用 &T 或 &mut T" },
          { id: "b", text: "宏展开" },
          { id: "c", text: "GC" },
          { id: "d", text: "动态链接" },
        ],
        answer: ["a"],
      },
      { id: "own-q7", type: "tf", prompt: "同一作用域内可以同时存在多个可变借用（&mut）。", options: tfOptions(), answer: ["f"] },
      { id: "own-q8", type: "tf", prompt: "同一作用域内可以同时存在多个不可变借用（&）。", options: tfOptions(), answer: ["t"] },
      { id: "own-q9", type: "tf", prompt: "当存在 &mut 借用时，不能同时存在对同一数据的 & 借用。", options: tfOptions(), answer: ["t"] },
      {
        id: "own-q10",
        type: "single",
        prompt: "切片（slice）最常见的表示是：",
        options: [
          { id: "a", text: "String" },
          { id: "b", text: "&str 或 &[T]" },
          { id: "c", text: "Vec<T>" },
          { id: "d", text: "Box<T>" },
        ],
        answer: ["b"],
      },
      { id: "own-q11", type: "tf", prompt: "Rust 的借用检查在编译期完成，不是运行时。", options: tfOptions(), answer: ["t"] },
      {
        id: "own-q12",
        type: "single",
        prompt: "下面哪项会导致悬垂引用风险而被 Rust 禁止？",
        options: [
          { id: "a", text: "返回一个引用指向局部变量" },
          { id: "b", text: "返回一个 String" },
          { id: "c", text: "返回 i32" },
          { id: "d", text: "返回 Vec<i32>" },
        ],
        answer: ["a"],
      },
      { id: "own-q13", type: "tf", prompt: "把 &String 传入函数不会转移所有权。", options: tfOptions(), answer: ["t"] },
      {
        id: "own-q14",
        type: "single",
        prompt: "当你把参数类型写成 `String`（不是 &str），通常意味着：",
        options: [
          { id: "a", text: "借用输入，不获取所有权" },
          { id: "b", text: "获取所有权（可能发生 move）" },
          { id: "c", text: "只读访问全局变量" },
          { id: "d", text: "强制 Copy" },
        ],
        answer: ["b"],
      },
      { id: "own-q15", type: "tf", prompt: "引用的默认行为是不可变借用（&T）。", options: tfOptions(), answer: ["t"] },
      {
        id: "own-q16",
        type: "single",
        prompt: "借用规则的目的主要是：",
        options: [
          { id: "a", text: "让代码更短" },
          { id: "b", text: "在编译期防止数据竞争与悬垂引用" },
          { id: "c", text: "实现 JIT" },
          { id: "d", text: "替代模块系统" },
        ],
        answer: ["b"],
      },
      { id: "own-q17", type: "tf", prompt: "可变借用允许修改数据，但仍不转移所有权。", options: tfOptions(), answer: ["t"] },
      {
        id: "own-q18",
        type: "single",
        prompt: "下面哪项更像“所有权转移”的触发？",
        options: [
          { id: "a", text: "把 i32 赋值给另一个变量" },
          { id: "b", text: "把 String 作为参数传给按值接收的函数" },
          { id: "c", text: "把 &str 赋值给另一个变量" },
          { id: "d", text: "复制 bool" },
        ],
        answer: ["b"],
      },
      { id: "own-q19", type: "tf", prompt: "String 字面量 \"hi\" 的类型是 String。", options: tfOptions(), answer: ["f"] },
      {
        id: "own-q20",
        type: "single",
        prompt: "当你需要同时读写同一份数据并跨线程共享，常见组合是：",
        options: [
          { id: "a", text: "Rc<RefCell<T>>" },
          { id: "b", text: "Arc<Mutex<T>>" },
          { id: "c", text: "&mut T" },
          { id: "d", text: "Box<T>" },
        ],
        answer: ["b"],
      },
    ],
  },

  structs: {
    sectionId: "structs",
    title: "结构体 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "st-q1", type: "tf", prompt: "结构体用于把多个相关字段组合成一个类型。", options: tfOptions(), answer: ["t"] },
      {
        id: "st-q2",
        type: "single",
        prompt: "为结构体实例化时，字段顺序：",
        options: [
          { id: "a", text: "必须严格按定义顺序" },
          { id: "b", text: "使用字段名初始化，不依赖顺序" },
          { id: "c", text: "必须按字母序" },
          { id: "d", text: "只能用元组方式" },
        ],
        answer: ["b"],
      },
      { id: "st-q3", type: "tf", prompt: "元组结构体（tuple struct）没有具名字段。", options: tfOptions(), answer: ["t"] },
      { id: "st-q4", type: "tf", prompt: "结构体更新语法 `..other` 会移动未显式指定的字段。", options: tfOptions(), answer: ["t"] },
      {
        id: "st-q5",
        type: "single",
        prompt: "方法（method）通常定义在：",
        options: [
          { id: "a", text: "impl 块中，并以 self/&self/&mut self 作为第一个参数" },
          { id: "b", text: "只能在 main 里" },
          { id: "c", text: "只能在 trait 里" },
          { id: "d", text: "只能在宏里" },
        ],
        answer: ["a"],
      },
      { id: "st-q6", type: "tf", prompt: "关联函数（associated function）不需要 self 参数。", options: tfOptions(), answer: ["t"] },
      {
        id: "st-q7",
        type: "single",
        prompt: "要打印调试信息，最常用的派生是：",
        options: [
          { id: "a", text: "#[derive(Debug)]" },
          { id: "b", text: "#[derive(Copy)]" },
          { id: "c", text: "#[derive(Send)]" },
          { id: "d", text: "#[derive(Async)]" },
        ],
        answer: ["a"],
      },
      { id: "st-q8", type: "tf", prompt: "结构体字段默认是 pub。", options: tfOptions(), answer: ["f"] },
      { id: "st-q9", type: "tf", prompt: "使用 `self` 会发生所有权移动，`&self` 不会。", options: tfOptions(), answer: ["t"] },
      {
        id: "st-q10",
        type: "single",
        prompt: "下面哪项是合法的结构体字段访问？",
        options: [
          { id: "a", text: "p->x" },
          { id: "b", text: "p.x" },
          { id: "c", text: "p[x]" },
          { id: "d", text: "p::x" },
        ],
        answer: ["b"],
      },
      { id: "st-q11", type: "tf", prompt: "可以在 impl 中定义多个方法与关联函数。", options: tfOptions(), answer: ["t"] },
      {
        id: "st-q12",
        type: "single",
        prompt: "当结构体字段也是 String 时，更新语法 `..other` 可能导致：",
        options: [
          { id: "a", text: "other 仍完全可用" },
          { id: "b", text: "other 的被移动字段不再可用" },
          { id: "c", text: "other 自动 clone" },
          { id: "d", text: "编译器忽略更新语法" },
        ],
        answer: ["b"],
      },
      { id: "st-q13", type: "tf", prompt: "可以为结构体实现 trait。", options: tfOptions(), answer: ["t"] },
      {
        id: "st-q14",
        type: "single",
        prompt: "若方法签名是 `fn take(self)`，调用后：",
        options: [
          { id: "a", text: "实例仍可继续使用" },
          { id: "b", text: "实例被移动，通常不能再用" },
          { id: "c", text: "实例自动复制" },
          { id: "d", text: "实例变成 'static" },
        ],
        answer: ["b"],
      },
      { id: "st-q15", type: "tf", prompt: "结构体可以包含引用字段，但需要生命周期标注。", options: tfOptions(), answer: ["t"] },
      {
        id: "st-q16",
        type: "single",
        prompt: "下面哪种更适合表示“无字段的标记类型”？",
        options: [
          { id: "a", text: "unit-like struct（单元结构体）" },
          { id: "b", text: "HashMap" },
          { id: "c", text: "Vec" },
          { id: "d", text: "union" },
        ],
        answer: ["a"],
      },
      { id: "st-q17", type: "tf", prompt: "方法调用时 Rust 会自动为你做引用/解引用的匹配（autoref/autoderef）。", options: tfOptions(), answer: ["t"] },
      {
        id: "st-q18",
        type: "single",
        prompt: "下面哪项不是结构体常见用途？",
        options: [
          { id: "a", text: "表示一类有多个属性的实体" },
          { id: "b", text: "封装状态与行为（方法）" },
          { id: "c", text: "把 unrelated 的全局变量塞一起" },
          { id: "d", text: "承载配置/参数" },
        ],
        answer: ["c"],
      },
      { id: "st-q19", type: "tf", prompt: "结构体字段的可变性由绑定是否 mut 决定，而不是字段类型。", options: tfOptions(), answer: ["t"] },
      {
        id: "st-q20",
        type: "single",
        prompt: "如果要写构造函数风格 API，最常见的做法是：",
        options: [
          { id: "a", text: "在 impl 中写 `fn new(...) -> Self`" },
          { id: "b", text: "必须用宏" },
          { id: "c", text: "必须用 trait" },
          { id: "d", text: "只能用 main" },
        ],
        answer: ["a"],
      },
    ],
  },

  enums: {
    sectionId: "enums",
    title: "枚举与模式匹配 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "en-q1", type: "tf", prompt: "枚举允许一个类型有多个变体（variants）。", options: tfOptions(), answer: ["t"] },
      { id: "en-q2", type: "tf", prompt: "Rust 的 match 必须穷尽所有可能分支。", options: tfOptions(), answer: ["t"] },
      {
        id: "en-q3",
        type: "single",
        prompt: "Option<T> 的两个变体是：",
        options: [
          { id: "a", text: "Ok/Err" },
          { id: "b", text: "Some/None" },
          { id: "c", text: "Yes/No" },
          { id: "d", text: "True/False" },
        ],
        answer: ["b"],
      },
      {
        id: "en-q4",
        type: "single",
        prompt: "Result<T, E> 的两个变体是：",
        options: [
          { id: "a", text: "Some/None" },
          { id: "b", text: "Ok/Err" },
          { id: "c", text: "Left/Right" },
          { id: "d", text: "Pass/Fail" },
        ],
        answer: ["b"],
      },
      { id: "en-q5", type: "tf", prompt: "match 是表达式，可以返回值。", options: tfOptions(), answer: ["t"] },
      {
        id: "en-q6",
        type: "single",
        prompt: "if let 主要用于：",
        options: [
          { id: "a", text: "替代所有 match" },
          { id: "b", text: "只关心一种模式，忽略其他情况" },
          { id: "c", text: "定义 trait" },
          { id: "d", text: "定义宏" },
        ],
        answer: ["b"],
      },
      { id: "en-q7", type: "tf", prompt: "枚举变体可以携带数据（例如 Some(i32)）。", options: tfOptions(), answer: ["t"] },
      { id: "en-q8", type: "tf", prompt: "match 分支里的绑定（例如 Some(x)）会移动所有权，除非匹配引用。", options: tfOptions(), answer: ["t"] },
      {
        id: "en-q9",
        type: "single",
        prompt: "下面哪个 pattern 可以匹配任意值并忽略它？",
        options: [
          { id: "a", text: "_" },
          { id: "b", text: "=>" },
          { id: "c", text: "::" },
          { id: "d", text: "??" },
        ],
        answer: ["a"],
      },
      { id: "en-q10", type: "tf", prompt: "在 match 中使用 _ 分支可以满足穷尽性要求。", options: tfOptions(), answer: ["t"] },
      {
        id: "en-q11",
        type: "single",
        prompt: "下面哪项是枚举常见用法？",
        options: [
          { id: "a", text: "表示一组互斥状态（state）" },
          { id: "b", text: "表示任意长度数组" },
          { id: "c", text: "替代所有 struct" },
          { id: "d", text: "绕过类型系统" },
        ],
        answer: ["a"],
      },
      { id: "en-q12", type: "tf", prompt: "Option 和 Result 都是枚举。", options: tfOptions(), answer: ["t"] },
      {
        id: "en-q13",
        type: "single",
        prompt: "如果你只想在 Some(x) 时执行逻辑，None 什么也不做，最简写法是：",
        options: [
          { id: "a", text: "match opt { Some(x) => ..., None => () }" },
          { id: "b", text: "if let Some(x) = opt { ... }" },
          { id: "c", text: "unwrap()" },
          { id: "d", text: "panic!" },
        ],
        answer: ["b"],
      },
      { id: "en-q14", type: "tf", prompt: "枚举的每个变体都必须是同一种数据类型。", options: tfOptions(), answer: ["f"] },
      { id: "en-q15", type: "tf", prompt: "match 分支返回值类型必须一致。", options: tfOptions(), answer: ["t"] },
      {
        id: "en-q16",
        type: "single",
        prompt: "下面哪项更贴近“用枚举实现多态”？",
        options: [
          { id: "a", text: "enum Message { Quit, Move {x: i32, y: i32} }" },
          { id: "b", text: "let x = 1;" },
          { id: "c", text: "fn main() {}" },
          { id: "d", text: "const N: i32 = 3;" },
        ],
        answer: ["a"],
      },
      { id: "en-q17", type: "tf", prompt: "if let 不能处理 else 分支。", options: tfOptions(), answer: ["f"] },
      {
        id: "en-q18",
        type: "single",
        prompt: "使用 `match` 的优点之一是：",
        options: [
          { id: "a", text: "可以保证处理完所有情况" },
          { id: "b", text: "运行时更慢" },
          { id: "c", text: "必须写很多 unsafe" },
          { id: "d", text: "只能匹配整数" },
        ],
        answer: ["a"],
      },
      { id: "en-q19", type: "tf", prompt: "模式匹配可以解构结构体与元组。", options: tfOptions(), answer: ["t"] },
      { id: "en-q20", type: "tf", prompt: "使用 if let 往往比 match 更“显式穷尽”。", options: tfOptions(), answer: ["f"] },
    ],
  },

  generics: {
    sectionId: "generics",
    title: "泛型 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "gen-q1", type: "tf", prompt: "泛型允许在不重复代码的情况下处理多种类型。", options: tfOptions(), answer: ["t"] },
      {
        id: "gen-q2",
        type: "single",
        prompt: "Rust 泛型通常在编译期通过什么机制实现高性能？",
        options: [
          { id: "a", text: "运行时反射" },
          { id: "b", text: "单态化（monomorphization）" },
          { id: "c", text: "JIT" },
          { id: "d", text: "GC" },
        ],
        answer: ["b"],
      },
      { id: "gen-q3", type: "tf", prompt: "为泛型添加 trait bounds 可以限制可用操作。", options: tfOptions(), answer: ["t"] },
      {
        id: "gen-q4",
        type: "single",
        prompt: "下面哪项是泛型函数签名示例？",
        options: [
          { id: "a", text: "fn foo(x: i32) -> i32" },
          { id: "b", text: "fn foo<T>(x: T) -> T" },
          { id: "c", text: "fn foo(x) -> x" },
          { id: "d", text: "fn foo() -> dyn Any" },
        ],
        answer: ["b"],
      },
      { id: "gen-q5", type: "tf", prompt: "泛型结构体可以包含不同类型参数。", options: tfOptions(), answer: ["t"] },
      {
        id: "gen-q6",
        type: "single",
        prompt: "下面哪项更可能需要 trait bound？",
        options: [
          { id: "a", text: "对泛型参数做 + 运算" },
          { id: "b", text: "把泛型参数移动进函数" },
          { id: "c", text: "把泛型参数放进 Vec" },
          { id: "d", text: "返回泛型参数" },
        ],
        answer: ["a"],
      },
      { id: "gen-q7", type: "tf", prompt: "where 子句可用于写更可读的复杂约束。", options: tfOptions(), answer: ["t"] },
      {
        id: "gen-q8",
        type: "single",
        prompt: "下面哪个 trait bound 常用于比较大小？",
        options: [
          { id: "a", text: "Clone" },
          { id: "b", text: "PartialOrd" },
          { id: "c", text: "Drop" },
          { id: "d", text: "Send" },
        ],
        answer: ["b"],
      },
      { id: "gen-q9", type: "tf", prompt: "单态化通常会让编译产物变大，但运行时更快。", options: tfOptions(), answer: ["t"] },
      { id: "gen-q10", type: "tf", prompt: "Rust 的泛型需要在运行时携带类型信息才能工作。", options: tfOptions(), answer: ["f"] },
      {
        id: "gen-q11",
        type: "single",
        prompt: "实现泛型方法时常见写法是：",
        options: [
          { id: "a", text: "impl<T> Foo<T> { ... }" },
          { id: "b", text: "impl Foo { <T> ... }" },
          { id: "c", text: "fn impl<T>()" },
          { id: "d", text: "trait impl" },
        ],
        answer: ["a"],
      },
      { id: "gen-q12", type: "tf", prompt: "可以为具体类型参数实现特化实现（specialization）在 stable 默认可用。", options: tfOptions(), answer: ["f"] },
      {
        id: "gen-q13",
        type: "single",
        prompt: "下面哪项是泛型枚举示例？",
        options: [
          { id: "a", text: "enum Option<T> { Some(T), None }" },
          { id: "b", text: "enum Color { Red, Green }" },
          { id: "c", text: "struct S(i32)" },
          { id: "d", text: "fn main()" },
        ],
        answer: ["a"],
      },
      { id: "gen-q14", type: "tf", prompt: "泛型参数命名通常使用单个大写字母（如 T、U）。", options: tfOptions(), answer: ["t"] },
      {
        id: "gen-q15",
        type: "single",
        prompt: "如果函数要打印泛型参数，常见 bound 是：",
        options: [
          { id: "a", text: "Debug" },
          { id: "b", text: "Drop" },
          { id: "c", text: "Send" },
          { id: "d", text: "FnOnce" },
        ],
        answer: ["a"],
      },
      { id: "gen-q16", type: "tf", prompt: "trait bound 既可用于函数，也可用于 impl 块。", options: tfOptions(), answer: ["t"] },
      {
        id: "gen-q17",
        type: "single",
        prompt: "下面哪项更贴近“泛型 + trait bound 的目的”？",
        options: [
          { id: "a", text: "让任何类型都能使用 + 运算" },
          { id: "b", text: "只允许满足某些能力的类型被使用" },
          { id: "c", text: "让编译器忽略类型检查" },
          { id: "d", text: "让代码自动并行" },
        ],
        answer: ["b"],
      },
      { id: "gen-q18", type: "tf", prompt: "泛型能减少重复代码，但可能增加编译时间。", options: tfOptions(), answer: ["t"] },
      {
        id: "gen-q19",
        type: "single",
        prompt: "若你只需要接受“实现了某 trait 的任何类型”，语法之一是：",
        options: [
          { id: "a", text: "dyn Trait（在参数位置）" },
          { id: "b", text: "impl Trait（在参数位置）" },
          { id: "c", text: "unsafe Trait" },
          { id: "d", text: "static Trait" },
        ],
        answer: ["b"],
      },
      { id: "gen-q20", type: "tf", prompt: "泛型在 Rust 中是“零成本抽象”的重要基础之一。", options: tfOptions(), answer: ["t"] },
    ],
  },

  traits: {
    sectionId: "traits",
    title: "Trait · 章节测验",
    passPercent: 90,
    questions: [
      { id: "tr-q1", type: "tf", prompt: "trait 用于定义一组类型应实现的行为（方法签名等）。", options: tfOptions(), answer: ["t"] },
      { id: "tr-q2", type: "tf", prompt: "trait 可以提供默认方法实现。", options: tfOptions(), answer: ["t"] },
      {
        id: "tr-q3",
        type: "single",
        prompt: "为某类型实现 trait 的关键字组合是：",
        options: [
          { id: "a", text: "trait for" },
          { id: "b", text: "impl Trait for Type" },
          { id: "c", text: "use Trait as Type" },
          { id: "d", text: "derive Trait" },
        ],
        answer: ["b"],
      },
      { id: "tr-q4", type: "tf", prompt: "trait bound 可以约束泛型参数必须实现某 trait。", options: tfOptions(), answer: ["t"] },
      {
        id: "tr-q5",
        type: "single",
        prompt: "下面哪种语法是 trait 作为参数的简写？",
        options: [
          { id: "a", text: "&impl Summary" },
          { id: "b", text: "impl Summary" },
          { id: "c", text: "Summary<impl>" },
          { id: "d", text: "Summary::impl" },
        ],
        answer: ["b"],
      },
      { id: "tr-q6", type: "tf", prompt: "返回 `impl Trait` 可以隐藏具体返回类型（但必须是单一具体类型）。", options: tfOptions(), answer: ["t"] },
      { id: "tr-q7", type: "tf", prompt: "trait 只能定义方法，不能定义关联常量/类型。", options: tfOptions(), answer: ["f"] },
      {
        id: "tr-q8",
        type: "single",
        prompt: "下面哪个 trait bound 常用于格式化输出？",
        options: [
          { id: "a", text: "Debug" },
          { id: "b", text: "Iterator" },
          { id: "c", text: "Drop" },
          { id: "d", text: "Sized" },
        ],
        answer: ["a"],
      },
      { id: "tr-q9", type: "tf", prompt: "可以为外部类型实现外部 trait（孤儿规则允许）。", options: tfOptions(), answer: ["f"] },
      {
        id: "tr-q10",
        type: "single",
        prompt: "孤儿规则（orphan rule）的大意是：",
        options: [
          { id: "a", text: "只能在 main.rs 定义 trait" },
          { id: "b", text: "实现 trait 时，trait 或类型至少有一个在当前 crate 中定义" },
          { id: "c", text: "trait 不能有默认实现" },
          { id: "d", text: "trait 不能用于泛型" },
        ],
        answer: ["b"],
      },
      { id: "tr-q11", type: "tf", prompt: "trait 让你可以写基于行为的抽象，而不是具体类型。", options: tfOptions(), answer: ["t"] },
      {
        id: "tr-q12",
        type: "single",
        prompt: "下面哪项是 trait bound 的写法？",
        options: [
          { id: "a", text: "fn f<T>(x: T) where T: Clone" },
          { id: "b", text: "fn f(x) -> T" },
          { id: "c", text: "trait f<T>" },
          { id: "d", text: "impl fn f" },
        ],
        answer: ["a"],
      },
      { id: "tr-q13", type: "tf", prompt: "默认方法实现可以在 impl 中被覆盖。", options: tfOptions(), answer: ["t"] },
      {
        id: "tr-q14",
        type: "single",
        prompt: "当你需要在集合里存放不同类型但共享行为时，常见方案是：",
        options: [
          { id: "a", text: "用 enum 把可能类型列出来" },
          { id: "b", text: "用宏替换类型系统" },
          { id: "c", text: "把所有类型转成 i32" },
          { id: "d", text: "用 static mut 存储" },
        ],
        answer: ["a"],
        explanation: "在本教程范围内，enum 是最直接且零成本的方式；trait object 属于更进阶主题。",
      },
      { id: "tr-q15", type: "tf", prompt: "trait 可以作为返回值类型而不暴露具体类型（impl Trait）。", options: tfOptions(), answer: ["t"] },
      { id: "tr-q16", type: "tf", prompt: "trait bounds 只会影响运行时，不影响编译期。", options: tfOptions(), answer: ["f"] },
      {
        id: "tr-q17",
        type: "single",
        prompt: "以下哪项更贴近 trait 的价值？",
        options: [
          { id: "a", text: "减少编译时间" },
          { id: "b", text: "定义行为契约并实现可复用的抽象" },
          { id: "c", text: "自动生成 UI" },
          { id: "d", text: "替代所有权系统" },
        ],
        answer: ["b"],
      },
      { id: "tr-q18", type: "tf", prompt: "可以为同一类型实现同一 trait 多次（用不同 impl）。", options: tfOptions(), answer: ["f"] },
      {
        id: "tr-q19",
        type: "single",
        prompt: "如果你在函数参数里写 `item: &impl Summary`，它等价于：",
        options: [
          { id: "a", text: "item: &(dyn Summary)" },
          { id: "b", text: "item: &T where T: Summary" },
          { id: "c", text: "item: Summary" },
          { id: "d", text: "item: Option<Summary>" },
        ],
        answer: ["b"],
      },
      { id: "tr-q20", type: "tf", prompt: "trait 与泛型结合是 Rust 抽象能力的核心之一。", options: tfOptions(), answer: ["t"] },
    ],
  },

  collections: {
    sectionId: "collections",
    title: "常用集合 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "col-q1", type: "tf", prompt: "Vec<T> 是最常用的可增长顺序集合。", options: tfOptions(), answer: ["t"] },
      { id: "col-q2", type: "tf", prompt: "使用索引访问 Vec 越界会返回 None。", options: tfOptions(), answer: ["f"] },
      {
        id: "col-q3",
        type: "single",
        prompt: "安全地访问 Vec 元素（避免 panic）应使用：",
        options: [
          { id: "a", text: "v[i]" },
          { id: "b", text: "v.get(i)" },
          { id: "c", text: "v.index(i)" },
          { id: "d", text: "v.at(i)" },
        ],
        answer: ["b"],
      },
      { id: "col-q4", type: "tf", prompt: "String 在 Rust 中保证是有效 UTF-8。", options: tfOptions(), answer: ["t"] },
      { id: "col-q5", type: "tf", prompt: "Rust 允许用 s[0] 直接索引 String 得到第一个字符。", options: tfOptions(), answer: ["f"] },
      {
        id: "col-q6",
        type: "single",
        prompt: "拼接多个 String 而不移动左侧所有权，常用的是：",
        options: [
          { id: "a", text: "+ 运算符" },
          { id: "b", text: "format!" },
          { id: "c", text: "panic!" },
          { id: "d", text: "dbg!" },
        ],
        answer: ["b"],
      },
      { id: "col-q7", type: "tf", prompt: "HashMap<K, V> 不是 prelude，需要 use std::collections::HashMap。", options: tfOptions(), answer: ["t"] },
      { id: "col-q8", type: "tf", prompt: "HashMap 是有序的，迭代时按插入顺序输出。", options: tfOptions(), answer: ["f"] },
      {
        id: "col-q9",
        type: "single",
        prompt: "HashMap 的 entry API 常用于：",
        options: [
          { id: "a", text: "实现条件插入/更新" },
          { id: "b", text: "把 HashMap 变成 Vec" },
          { id: "c", text: "把 key 转成大写" },
          { id: "d", text: "删除所有元素" },
        ],
        answer: ["a"],
      },
      { id: "col-q10", type: "tf", prompt: "or_insert 返回的是可变引用，可用于更新值。", options: tfOptions(), answer: ["t"] },
      {
        id: "col-q11",
        type: "single",
        prompt: "把 Vec 中的所有元素都加 1，最常见的可变遍历是：",
        options: [
          { id: "a", text: "for x in v { x += 1 }" },
          { id: "b", text: "for x in &v { *x += 1 }" },
          { id: "c", text: "for x in &mut v { *x += 1 }" },
          { id: "d", text: "v.each(|x| x += 1)" },
        ],
        answer: ["c"],
      },
      { id: "col-q12", type: "tf", prompt: "Vec::new() 有时需要类型注解，因为无法推断 T。", options: tfOptions(), answer: ["t"] },
      {
        id: "col-q13",
        type: "single",
        prompt: "String 添加字符可以用：",
        options: [
          { id: "a", text: "push" },
          { id: "b", text: "insert_map" },
          { id: "c", text: "extend_hash" },
          { id: "d", text: "concat!" },
        ],
        answer: ["a"],
      },
      { id: "col-q14", type: "tf", prompt: "String 的 push_str 会追加 &str。", options: tfOptions(), answer: ["t"] },
      {
        id: "col-q15",
        type: "single",
        prompt: "遍历字符串的 Unicode 字符应使用：",
        options: [
          { id: "a", text: "bytes()" },
          { id: "b", text: "chars()" },
          { id: "c", text: "indexing" },
          { id: "d", text: "as_ptr()" },
        ],
        answer: ["b"],
      },
      { id: "col-q16", type: "tf", prompt: "HashMap 插入键值对时，如果 key 是 String，插入会移动 key 的所有权。", options: tfOptions(), answer: ["t"] },
      {
        id: "col-q17",
        type: "single",
        prompt: "使用 zip + collect 从两个 Vec 构建 HashMap，collect 的类型通常写成：",
        options: [
          { id: "a", text: "collect::<Vec<_>>()" },
          { id: "b", text: "collect::<HashMap<_, _>>()" },
          { id: "c", text: "collect::<String>()" },
          { id: "d", text: "collect::<Option<_>>()" },
        ],
        answer: ["b"],
      },
      { id: "col-q18", type: "tf", prompt: "format! 会创建新的 String，不会移动原来的 String 参数。", options: tfOptions(), answer: ["t"] },
      { id: "col-q19", type: "tf", prompt: "Vec 可以存放不同类型元素，只要它们都实现 Debug。", options: tfOptions(), answer: ["f"] },
      {
        id: "col-q20",
        type: "single",
        prompt: "想在 Vec 里存放不同类型值，常见做法是：",
        options: [
          { id: "a", text: "使用枚举把多种类型包起来" },
          { id: "b", text: "直接混放" },
          { id: "c", text: "用 static mut" },
          { id: "d", text: "用生命周期延长" },
        ],
        answer: ["a"],
      },
    ],
  },

  functional: {
    sectionId: "functional",
    title: "闭包与迭代器 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "fn-q1", type: "tf", prompt: "闭包可以捕获外部环境变量。", options: tfOptions(), answer: ["t"] },
      {
        id: "fn-q2",
        type: "single",
        prompt: "下面哪个 trait 表示闭包可能会消耗捕获的值（只能调用一次）？",
        options: [
          { id: "a", text: "Fn" },
          { id: "b", text: "FnMut" },
          { id: "c", text: "FnOnce" },
          { id: "d", text: "Drop" },
        ],
        answer: ["c"],
      },
      { id: "fn-q3", type: "tf", prompt: "move 闭包会把捕获变量的所有权移动进闭包。", options: tfOptions(), answer: ["t"] },
      { id: "fn-q4", type: "tf", prompt: "迭代器适配器（如 map/filter）通常是惰性的。", options: tfOptions(), answer: ["t"] },
      {
        id: "fn-q5",
        type: "single",
        prompt: "下面哪个是“消费型（consuming）适配器”？",
        options: [
          { id: "a", text: "map" },
          { id: "b", text: "filter" },
          { id: "c", text: "collect" },
          { id: "d", text: "inspect" },
        ],
        answer: ["c"],
      },
      { id: "fn-q6", type: "tf", prompt: "iter() 通常产生 &T。", options: tfOptions(), answer: ["t"] },
      { id: "fn-q7", type: "tf", prompt: "into_iter() 通常会移动集合的所有权并产生 T。", options: tfOptions(), answer: ["t"] },
      {
        id: "fn-q8",
        type: "single",
        prompt: "把一组 &str 解析为 i32，并在遇到第一个错误时停止，常用的是：",
        options: [
          { id: "a", text: "collect::<Vec<_>>()" },
          { id: "b", text: "collect::<Result<Vec<_>, _>>()" },
          { id: "c", text: "sum::<Result<_>>() " },
          { id: "d", text: "unwrap_or_default()" },
        ],
        answer: ["b"],
      },
      { id: "fn-q9", type: "tf", prompt: "闭包参数类型有时可以省略让编译器推断。", options: tfOptions(), answer: ["t"] },
      {
        id: "fn-q10",
        type: "single",
        prompt: "下面哪项更贴近“迭代器的优势”？",
        options: [
          { id: "a", text: "一定比 for 更快" },
          { id: "b", text: "可组合的惰性流水线，表达意图更清晰" },
          { id: "c", text: "绕过借用检查" },
          { id: "d", text: "替代所有权" },
        ],
        answer: ["b"],
      },
      { id: "fn-q11", type: "tf", prompt: "sum 会消费迭代器。", options: tfOptions(), answer: ["t"] },
      { id: "fn-q12", type: "tf", prompt: "map 会立刻执行并产生一个 Vec。", options: tfOptions(), answer: ["f"] },
      {
        id: "fn-q13",
        type: "single",
        prompt: "要把 Vec<i32> 每个元素乘 2 并收集为 Vec<i32>，最常见组合是：",
        options: [
          { id: "a", text: "iter().map(...).collect()" },
          { id: "b", text: "bytes().collect()" },
          { id: "c", text: "chars().sum()" },
          { id: "d", text: "zip().count()" },
        ],
        answer: ["a"],
      },
      { id: "fn-q14", type: "tf", prompt: "FnMut 表示闭包可能会修改捕获的环境。", options: tfOptions(), answer: ["t"] },
      {
        id: "fn-q15",
        type: "single",
        prompt: "下面哪项常用于调试迭代器链条但不改变值？",
        options: [
          { id: "a", text: "inspect" },
          { id: "b", text: "collect" },
          { id: "c", text: "sum" },
          { id: "d", text: "last" },
        ],
        answer: ["a"],
      },
      { id: "fn-q16", type: "tf", prompt: "在 for 循环里使用 &mut 可以就地修改元素。", options: tfOptions(), answer: ["t"] },
      { id: "fn-q17", type: "tf", prompt: "迭代器的很多方法靠 trait 组合实现（Iterator trait）。", options: tfOptions(), answer: ["t"] },
      {
        id: "fn-q18",
        type: "single",
        prompt: "如果你想避免 into_iter 移动所有权，应优先使用：",
        options: [
          { id: "a", text: "iter()" },
          { id: "b", text: "drop()" },
          { id: "c", text: "panic!" },
          { id: "d", text: "unsafe" },
        ],
        answer: ["a"],
      },
      { id: "fn-q19", type: "tf", prompt: "闭包一定比函数更慢。", options: tfOptions(), answer: ["f"] },
      { id: "fn-q20", type: "tf", prompt: "迭代器组合与泛型/trait 密切相关，是 Rust 风格代码的常见形态。", options: tfOptions(), answer: ["t"] },
    ],
  },

  testing: {
    sectionId: "testing",
    title: "测试 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "ts-q1", type: "tf", prompt: "#[test] 标注的函数会被 cargo test 运行。", options: tfOptions(), answer: ["t"] },
      { id: "ts-q2", type: "tf", prompt: "测试模块常用 #[cfg(test)] 隔离，只在测试时编译。", options: tfOptions(), answer: ["t"] },
      {
        id: "ts-q3",
        type: "single",
        prompt: "断言相等最常用的宏是：",
        options: [
          { id: "a", text: "assert_eq!" },
          { id: "b", text: "println!" },
          { id: "c", text: "dbg!" },
          { id: "d", text: "vec!" },
        ],
        answer: ["a"],
      },
      { id: "ts-q4", type: "tf", prompt: "#[should_panic] 用于测试代码会 panic 的场景。", options: tfOptions(), answer: ["t"] },
      { id: "ts-q5", type: "tf", prompt: "测试函数不能返回 Result。", options: tfOptions(), answer: ["f"] },
      {
        id: "ts-q6",
        type: "single",
        prompt: "集成测试通常放在：",
        options: [
          { id: "a", text: "tests/" },
          { id: "b", text: "src/tests/" },
          { id: "c", text: "target/tests/" },
          { id: "d", text: ".cargo/tests/" },
        ],
        answer: ["a"],
      },
      { id: "ts-q7", type: "tf", prompt: "集成测试只能通过 public API 访问被测 crate。", options: tfOptions(), answer: ["t"] },
      { id: "ts-q8", type: "tf", prompt: "doc tests 会编译并运行文档注释里的代码块。", options: tfOptions(), answer: ["t"] },
      {
        id: "ts-q9",
        type: "single",
        prompt: "只运行名字包含 add 的测试，可以用：",
        options: [
          { id: "a", text: "cargo test add" },
          { id: "b", text: "cargo run add" },
          { id: "c", text: "cargo fmt add" },
          { id: "d", text: "cargo doc add" },
        ],
        answer: ["a"],
      },
      { id: "ts-q10", type: "tf", prompt: "测试失败时 cargo test 会返回非 0。", options: tfOptions(), answer: ["t"] },
      { id: "ts-q11", type: "tf", prompt: "expected 参数可让 should_panic 更精确。", options: tfOptions(), answer: ["t"] },
      {
        id: "ts-q12",
        type: "single",
        prompt: "下面哪项是好的测试实践？",
        options: [
          { id: "a", text: "只测 happy path" },
          { id: "b", text: "覆盖边界与错误分支" },
          { id: "c", text: "把测试写成依赖外网" },
          { id: "d", text: "测试越慢越好" },
        ],
        answer: ["b"],
      },
      { id: "ts-q13", type: "tf", prompt: "二进制 crate 想做集成测试，通常建议抽出 lib.rs。", options: tfOptions(), answer: ["t"] },
      { id: "ts-q14", type: "tf", prompt: "文档测试能帮助保证文档示例不“过时”。", options: tfOptions(), answer: ["t"] },
      {
        id: "ts-q15",
        type: "single",
        prompt: "运行文档测试的命令是：",
        options: [
          { id: "a", text: "cargo test --doc" },
          { id: "b", text: "cargo doc --test" },
          { id: "c", text: "cargo fmt --doc" },
          { id: "d", text: "cargo run --doc" },
        ],
        answer: ["a"],
      },
      { id: "ts-q16", type: "tf", prompt: "assert! 失败会导致测试失败。", options: tfOptions(), answer: ["t"] },
      { id: "ts-q17", type: "tf", prompt: "测试模块里常用 use super::* 引入被测函数。", options: tfOptions(), answer: ["t"] },
      {
        id: "ts-q18",
        type: "single",
        prompt: "下面哪项更适合写成单元测试？",
        options: [
          { id: "a", text: "纯函数 search() 的大小写逻辑" },
          { id: "b", text: "跨进程调用真实服务" },
          { id: "c", text: "端到端 UI 自动化" },
          { id: "d", text: "压力测试" },
        ],
        answer: ["a"],
      },
      { id: "ts-q19", type: "tf", prompt: "测试名称（函数名）本身也是文档，应清晰表达意图。", options: tfOptions(), answer: ["t"] },
      { id: "ts-q20", type: "tf", prompt: "通过 cargo test 可以同时运行单元测试、集成测试与文档测试（默认行为的一部分）。", options: tfOptions(), answer: ["t"] },
    ],
  },

  lifetimes: {
    sectionId: "lifetimes",
    title: "生命周期 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "lt-q1", type: "tf", prompt: "生命周期用于确保引用在使用时始终有效。", options: tfOptions(), answer: ["t"] },
      { id: "lt-q2", type: "tf", prompt: "生命周期标注会改变引用实际存活时间。", options: tfOptions(), answer: ["f"] },
      {
        id: "lt-q3",
        type: "single",
        prompt: "当编译器无法推断引用关系时，需要：",
        options: [
          { id: "a", text: "写 unsafe" },
          { id: "b", text: "手动标注生命周期参数（如 'a）" },
          { id: "c", text: "加入 GC" },
          { id: "d", text: "把所有引用变成 'static" },
        ],
        answer: ["b"],
      },
      { id: "lt-q4", type: "tf", prompt: "'static 生命周期表示引用在整个程序运行期间有效。", options: tfOptions(), answer: ["t"] },
      {
        id: "lt-q5",
        type: "single",
        prompt: "下面哪个函数签名表达“返回引用与输入引用生命周期相关”？",
        options: [
          { id: "a", text: "fn f(x: &str) -> &str" },
          { id: "b", text: "fn f<'a>(x: &'a str) -> &'a str" },
          { id: "c", text: "fn f(x: String) -> &str" },
          { id: "d", text: "fn f() -> &str" },
        ],
        answer: ["b"],
      },
      { id: "lt-q6", type: "tf", prompt: "生命周期省略规则（elision）可以让很多常见场景不用写 'a。", options: tfOptions(), answer: ["t"] },
      { id: "lt-q7", type: "tf", prompt: "结构体字段包含引用时，通常需要在结构体上标注生命周期。", options: tfOptions(), answer: ["t"] },
      { id: "lt-q8", type: "tf", prompt: "返回局部变量引用会被借用检查器拒绝，避免悬垂引用。", options: tfOptions(), answer: ["t"] },
      {
        id: "lt-q9",
        type: "single",
        prompt: "下面哪项是生命周期标注的核心作用？",
        options: [
          { id: "a", text: "告诉编译器引用之间的关系" },
          { id: "b", text: "让引用更快" },
          { id: "c", text: "让引用变成可变" },
          { id: "d", text: "替代所有权" },
        ],
        answer: ["a"],
      },
      { id: "lt-q10", type: "tf", prompt: "多个引用参数时，返回值生命周期可能与其中一个相关，需要显式说明。", options: tfOptions(), answer: ["t"] },
      { id: "lt-q11", type: "tf", prompt: "生命周期问题只在运行时报错，编译期不会提示。", options: tfOptions(), answer: ["f"] },
      {
        id: "lt-q12",
        type: "single",
        prompt: "当函数返回 &str 并来自输入参数时，最常见的写法是：",
        options: [
          { id: "a", text: "返回 String" },
          { id: "b", text: "使用生命周期参数 'a 关联输入与输出" },
          { id: "c", text: "使用 unsafe" },
          { id: "d", text: "使用 static mut" },
        ],
        answer: ["b"],
      },
      { id: "lt-q13", type: "tf", prompt: "生命周期参数的名字必须叫 'a。", options: tfOptions(), answer: ["f"] },
      { id: "lt-q14", type: "tf", prompt: "生命周期与作用域相关，但并不等同于作用域。", options: tfOptions(), answer: ["t"] },
      {
        id: "lt-q15",
        type: "single",
        prompt: "下面哪项是常见的解决策略？",
        options: [
          { id: "a", text: "把引用改为拥有所有权的类型（如 String）" },
          { id: "b", text: "把所有 borrow 变成 &mut" },
          { id: "c", text: "禁用借用检查" },
          { id: "d", text: "把所有函数变成 unsafe" },
        ],
        answer: ["a"],
      },
      { id: "lt-q16", type: "tf", prompt: "生命周期标注不会产生运行时开销。", options: tfOptions(), answer: ["t"] },
      { id: "lt-q17", type: "tf", prompt: "如果你返回的是拥有所有权的值（如 String），通常不需要生命周期标注。", options: tfOptions(), answer: ["t"] },
      { id: "lt-q18", type: "tf", prompt: "引用总是比拥有所有权更好。", options: tfOptions(), answer: ["f"] },
      {
        id: "lt-q19",
        type: "single",
        prompt: "当你只想借用一部分字符串，通常使用：",
        options: [
          { id: "a", text: "&str 切片" },
          { id: "b", text: "String::clone" },
          { id: "c", text: "Box<String>" },
          { id: "d", text: "Rc<String>" },
        ],
        answer: ["a"],
      },
      { id: "lt-q20", type: "tf", prompt: "生命周期标注描述关系，而不是指定具体长度。", options: tfOptions(), answer: ["t"] },
    ],
  },

  concurrency: {
    sectionId: "concurrency",
    title: "并发编程 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "cc-q1", type: "tf", prompt: "thread::spawn 会创建新线程执行闭包。", options: tfOptions(), answer: ["t"] },
      { id: "cc-q2", type: "tf", prompt: "join 会等待线程结束。", options: tfOptions(), answer: ["t"] },
      { id: "cc-q3", type: "tf", prompt: "move 闭包常用于把所有权移动到新线程中。", options: tfOptions(), answer: ["t"] },
      {
        id: "cc-q4",
        type: "single",
        prompt: "mpsc 表示：",
        options: [
          { id: "a", text: "multiple producer, single consumer" },
          { id: "b", text: "multi process, single core" },
          { id: "c", text: "memory pinned, stack copied" },
          { id: "d", text: "macro parse, syntax check" },
        ],
        answer: ["a"],
      },
      { id: "cc-q5", type: "tf", prompt: "tx.send(val) 会转移 val 的所有权。", options: tfOptions(), answer: ["t"] },
      { id: "cc-q6", type: "tf", prompt: "rx.recv() 是非阻塞的。", options: tfOptions(), answer: ["f"] },
      {
        id: "cc-q7",
        type: "single",
        prompt: "在多线程中共享可变计数器的常见组合是：",
        options: [
          { id: "a", text: "Rc<RefCell<i32>>" },
          { id: "b", text: "Arc<Mutex<i32>>" },
          { id: "c", text: "Box<i32>" },
          { id: "d", text: "&mut i32" },
        ],
        answer: ["b"],
      },
      { id: "cc-q8", type: "tf", prompt: "Mutex 通过互斥保证同一时间只有一个线程访问数据。", options: tfOptions(), answer: ["t"] },
      { id: "cc-q9", type: "tf", prompt: "Arc 是线程安全版本的 Rc。", options: tfOptions(), answer: ["t"] },
      {
        id: "cc-q10",
        type: "single",
        prompt: "RwLock 的优势之一是：",
        options: [
          { id: "a", text: "允许多个读者同时读" },
          { id: "b", text: "允许多个写者同时写" },
          { id: "c", text: "不需要锁" },
          { id: "d", text: "自动避免死锁" },
        ],
        answer: ["a"],
      },
      { id: "cc-q11", type: "tf", prompt: "lock().unwrap() 可能 panic。", options: tfOptions(), answer: ["t"] },
      { id: "cc-q12", type: "tf", prompt: "Send/Sync trait 与线程安全有关。", options: tfOptions(), answer: ["t"] },
      { id: "cc-q13", type: "tf", prompt: "数据竞争（data race）在安全 Rust 中可以通过编译。", options: tfOptions(), answer: ["f"] },
      {
        id: "cc-q14",
        type: "single",
        prompt: "下面哪项更贴近 Rust 的并发模型？",
        options: [
          { id: "a", text: "尽量在编译期捕获并发错误（fearless concurrency）" },
          { id: "b", text: "完全依赖运行时锁检测" },
          { id: "c", text: "所有共享都用 static mut" },
          { id: "d", text: "禁止并发" },
        ],
        answer: ["a"],
      },
      { id: "cc-q15", type: "tf", prompt: "mpsc 的 Sender 可以 clone 以实现多个生产者。", options: tfOptions(), answer: ["t"] },
      { id: "cc-q16", type: "tf", prompt: "MutexGuard 离开作用域会自动释放锁。", options: tfOptions(), answer: ["t"] },
      {
        id: "cc-q17",
        type: "single",
        prompt: "使用共享状态并发时，最常见的问题之一是：",
        options: [
          { id: "a", text: "死锁" },
          { id: "b", text: "生命周期标注" },
          { id: "c", text: "宏卫生性" },
          { id: "d", text: "模块可见性" },
        ],
        answer: ["a"],
      },
      { id: "cc-q18", type: "tf", prompt: "消息传递（channel）能减少共享可变状态的需求。", options: tfOptions(), answer: ["t"] },
      { id: "cc-q19", type: "tf", prompt: "Arc 允许多个线程共享所有权。", options: tfOptions(), answer: ["t"] },
      { id: "cc-q20", type: "tf", prompt: "并发代码应尽量缩小锁粒度、避免持锁期间做耗时操作。", options: tfOptions(), answer: ["t"] },
    ],
  },

  async: {
    sectionId: "async",
    title: "异步编程 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "as-q1", type: "tf", prompt: "async fn 会返回一个实现 Future 的值。", options: tfOptions(), answer: ["t"] },
      { id: "as-q2", type: "tf", prompt: "await 会阻塞当前线程直到完成。", options: tfOptions(), answer: ["f"] },
      {
        id: "as-q3",
        type: "single",
        prompt: "Rust 标准库是否自带通用异步运行时（executor）？",
        options: [
          { id: "a", text: "是" },
          { id: "b", text: "否" },
          { id: "c", text: "只在 Windows 有" },
          { id: "d", text: "只在 nightly 有" },
        ],
        answer: ["b"],
      },
      { id: "as-q4", type: "tf", prompt: "Future 通过 poll() 被驱动向前推进。", options: tfOptions(), answer: ["t"] },
      { id: "as-q5", type: "tf", prompt: "真实 executor 需要 waker 来在资源就绪时唤醒任务。", options: tfOptions(), answer: ["t"] },
      {
        id: "as-q6",
        type: "single",
        prompt: "Tokio 的入口宏通常是：",
        options: [
          { id: "a", text: "#[tokio::main]" },
          { id: "b", text: "#[async::main]" },
          { id: "c", text: "#[future::main]" },
          { id: "d", text: "#[thread::main]" },
        ],
        answer: ["a"],
      },
      { id: "as-q7", type: "tf", prompt: "spawn_blocking 常用于把阻塞/CPU 密集任务放到专用线程池。", options: tfOptions(), answer: ["t"] },
      { id: "as-q8", type: "tf", prompt: "在 async 任务里调用 std::thread::sleep 是好的实践。", options: tfOptions(), answer: ["f"] },
      {
        id: "as-q9",
        type: "single",
        prompt: "异步中最常见的坑之一是：",
        options: [
          { id: "a", text: "把阻塞操作放进 async 任务" },
          { id: "b", text: "使用 Result" },
          { id: "c", text: "使用 match" },
          { id: "d", text: "使用 Vec" },
        ],
        answer: ["a"],
      },
      { id: "as-q10", type: "tf", prompt: "异步任务可能被取消，因此需要注意资源释放与一致性。", options: tfOptions(), answer: ["t"] },
      { id: "as-q11", type: "tf", prompt: "async/await 可以理解为编译器生成的状态机。", options: tfOptions(), answer: ["t"] },
      { id: "as-q12", type: "tf", prompt: "Future::poll 返回 Poll::Pending 表示“稍后再试”。", options: tfOptions(), answer: ["t"] },
      { id: "as-q13", type: "tf", prompt: "Tokio 的 time::sleep 是非阻塞的。", options: tfOptions(), answer: ["t"] },
      {
        id: "as-q14",
        type: "single",
        prompt: "下面哪项是 async 的优势之一？",
        options: [
          { id: "a", text: "让所有代码更短" },
          { id: "b", text: "提升 IO 密集场景并发吞吐" },
          { id: "c", text: "消除所有错误" },
          { id: "d", text: "不需要测试" },
        ],
        answer: ["b"],
      },
      { id: "as-q15", type: "tf", prompt: "异步代码中持锁后再 await 可能造成问题，应尽量避免。", options: tfOptions(), answer: ["t"] },
      {
        id: "as-q16",
        type: "single",
        prompt: "异步运行时的职责之一是：",
        options: [
          { id: "a", text: "调度任务并在 wake 后重新 poll" },
          { id: "b", text: "替代 borrow checker" },
          { id: "c", text: "生成 Cargo.lock" },
          { id: "d", text: "自动写单元测试" },
        ],
        answer: ["a"],
      },
      { id: "as-q17", type: "tf", prompt: "await 本质上是“让出执行权”，等待 Future 完成。", options: tfOptions(), answer: ["t"] },
      { id: "as-q18", type: "tf", prompt: "在 async 中，错误处理依旧推荐使用 Result。", options: tfOptions(), answer: ["t"] },
      { id: "as-q19", type: "tf", prompt: "异步一定比多线程更快。", options: tfOptions(), answer: ["f"] },
      { id: "as-q20", type: "tf", prompt: "工程实践中通常需要超时与取消策略来避免任务永久挂起。", options: tfOptions(), answer: ["t"] },
    ],
  },

  "smart-pointers": {
    sectionId: "smart-pointers",
    title: "智能指针 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "sp-q1", type: "tf", prompt: "Box<T> 用于在堆上分配数据。", options: tfOptions(), answer: ["t"] },
      { id: "sp-q2", type: "tf", prompt: "Rc<T> 适用于多线程共享所有权。", options: tfOptions(), answer: ["f"] },
      { id: "sp-q3", type: "tf", prompt: "Arc<T> 是线程安全的引用计数指针。", options: tfOptions(), answer: ["t"] },
      { id: "sp-q4", type: "tf", prompt: "RefCell<T> 通过运行时借用检查提供内部可变性。", options: tfOptions(), answer: ["t"] },
      {
        id: "sp-q5",
        type: "single",
        prompt: "Deref trait 主要用于：",
        options: [
          { id: "a", text: "自定义解引用行为，让智能指针像引用一样用 *" },
          { id: "b", text: "定义宏" },
          { id: "c", text: "并发调度" },
          { id: "d", text: "网络 IO" },
        ],
        answer: ["a"],
      },
      { id: "sp-q6", type: "tf", prompt: "Drop trait 允许你在值离开作用域时自定义清理逻辑。", options: tfOptions(), answer: ["t"] },
      { id: "sp-q7", type: "tf", prompt: "Box 可以用于定义递归类型（如链表）来让类型大小在编译期已知。", options: tfOptions(), answer: ["t"] },
      { id: "sp-q8", type: "tf", prompt: "Rc 的 clone 是深拷贝，会复制内部数据。", options: tfOptions(), answer: ["f"] },
      {
        id: "sp-q9",
        type: "single",
        prompt: "内部可变性（interior mutability）最贴近的含义是：",
        options: [
          { id: "a", text: "即使绑定不可变，也能通过特定类型在内部修改数据" },
          { id: "b", text: "所有字段都是 pub" },
          { id: "c", text: "所有权可以随意复制" },
          { id: "d", text: "所有引用都是 'static" },
        ],
        answer: ["a"],
      },
      { id: "sp-q10", type: "tf", prompt: "RefCell 的借用违规会在运行时 panic。", options: tfOptions(), answer: ["t"] },
      { id: "sp-q11", type: "tf", prompt: "Rc + RefCell 常用于单线程下的共享可变状态。", options: tfOptions(), answer: ["t"] },
      {
        id: "sp-q12",
        type: "single",
        prompt: "为避免引用计数循环导致内存泄漏，常用的是：",
        options: [
          { id: "a", text: "Weak<T>" },
          { id: "b", text: "Box<T>" },
          { id: "c", text: "String" },
          { id: "d", text: "Option<T>" },
        ],
        answer: ["a"],
      },
      { id: "sp-q13", type: "tf", prompt: "Weak<T> 不会增加强引用计数。", options: tfOptions(), answer: ["t"] },
      { id: "sp-q14", type: "tf", prompt: "Arc<Mutex<T>> 适用于多线程共享可变数据。", options: tfOptions(), answer: ["t"] },
      { id: "sp-q15", type: "tf", prompt: "Box<T> 的解引用需要显式写 *，编译器不会自动帮你。", options: tfOptions(), answer: ["f"] },
      {
        id: "sp-q16",
        type: "single",
        prompt: "下面哪项更贴近“智能指针”的特征？",
        options: [
          { id: "a", text: "实现 Deref/Drop 等 trait，具有额外行为" },
          { id: "b", text: "只能放在栈上" },
          { id: "c", text: "必须是 Copy" },
          { id: "d", text: "必须是 unsafe" },
        ],
        answer: ["a"],
      },
      { id: "sp-q17", type: "tf", prompt: "Rc 通过引用计数在运行时管理共享所有权。", options: tfOptions(), answer: ["t"] },
      { id: "sp-q18", type: "tf", prompt: "RefCell 让 borrow checker 在编译期完全失效。", options: tfOptions(), answer: ["f"] },
      { id: "sp-q19", type: "tf", prompt: "Weak::upgrade 可以尝试获得 Rc/Arc，如果值已释放则返回 None。", options: tfOptions(), answer: ["t"] },
      { id: "sp-q20", type: "tf", prompt: "智能指针经常用于表达所有权、共享与生命周期的工程约束。", options: tfOptions(), answer: ["t"] },
    ],
  },

  macros: {
    sectionId: "macros",
    title: "宏系统 · 章节测验",
    passPercent: 90,
    questions: [
      { id: "m-q1", type: "tf", prompt: "宏调用通常以 `!` 结尾。", options: tfOptions(), answer: ["t"] },
      { id: "m-q2", type: "tf", prompt: "macro_rules! 属于声明式宏（declarative macro）。", options: tfOptions(), answer: ["t"] },
      {
        id: "m-q3",
        type: "single",
        prompt: "宏的主要优势之一是：",
        options: [
          { id: "a", text: "在编译期生成重复样板代码" },
          { id: "b", text: "让运行时更慢" },
          { id: "c", text: "替代类型系统" },
          { id: "d", text: "只能用于打印" },
        ],
        answer: ["a"],
      },
      { id: "m-q4", type: "tf", prompt: "宏是在运行时展开的。", options: tfOptions(), answer: ["f"] },
      { id: "m-q5", type: "tf", prompt: "println!、vec! 都是宏。", options: tfOptions(), answer: ["t"] },
      {
        id: "m-q6",
        type: "single",
        prompt: "宏里常见的匹配片段类型（fragment specifier）之一是：",
        options: [
          { id: "a", text: "expr" },
          { id: "b", text: "heap" },
          { id: "c", text: "gc" },
          { id: "d", text: "jit" },
        ],
        answer: ["a"],
      },
      { id: "m-q7", type: "tf", prompt: "stringify! 可以把 token 转成字符串。", options: tfOptions(), answer: ["t"] },
      { id: "m-q8", type: "tf", prompt: "宏可以接收可变数量参数。", options: tfOptions(), answer: ["t"] },
      { id: "m-q9", type: "tf", prompt: "宏可以帮助减少重复模式代码，但也可能降低可读性。", options: tfOptions(), answer: ["t"] },
      {
        id: "m-q10",
        type: "single",
        prompt: "下面哪个更像宏定义的入口？",
        options: [
          { id: "a", text: "macro_rules!" },
          { id: "b", text: "trait_rules!" },
          { id: "c", text: "impl_rules!" },
          { id: "d", text: "use_rules!" },
        ],
        answer: ["a"],
      },
      { id: "m-q11", type: "tf", prompt: "dbg! 宏会打印表达式和值，并返回该值。", options: tfOptions(), answer: ["t"] },
      { id: "m-q12", type: "tf", prompt: "assert_eq! 失败会 panic。", options: tfOptions(), answer: ["t"] },
      {
        id: "m-q13",
        type: "single",
        prompt: "下面哪项更适合用宏实现？",
        options: [
          { id: "a", text: "重复的样板代码生成（如声明多个相似函数）" },
          { id: "b", text: "普通业务逻辑" },
          { id: "c", text: "网络请求" },
          { id: "d", text: "线程调度" },
        ],
        answer: ["a"],
      },
      { id: "m-q14", type: "tf", prompt: "宏展开发生在类型检查之后。", options: tfOptions(), answer: ["f"] },
      { id: "m-q15", type: "tf", prompt: "宏错误通常在编译时报出，定位可能比函数更难。", options: tfOptions(), answer: ["t"] },
      { id: "m-q16", type: "tf", prompt: "todo! 与 unimplemented! 都是宏。", options: tfOptions(), answer: ["t"] },
      {
        id: "m-q17",
        type: "single",
        prompt: "下面哪个宏最常用于格式化字符串生成新的 String？",
        options: [
          { id: "a", text: "format!" },
          { id: "b", text: "dbg!" },
          { id: "c", text: "vec!" },
          { id: "d", text: "panic!" },
        ],
        answer: ["a"],
      },
      { id: "m-q18", type: "tf", prompt: "宏可以在某些情况下减少运行时开销（因为在编译期展开）。", options: tfOptions(), answer: ["t"] },
      { id: "m-q19", type: "tf", prompt: "写宏时应该尽量让宏的接口清晰，避免难以理解的 DSL。", options: tfOptions(), answer: ["t"] },
      { id: "m-q20", type: "tf", prompt: "宏与泛型/trait 是互斥的，只能选其一。", options: tfOptions(), answer: ["f"] },
    ],
  },

  unsafe: {
    sectionId: "unsafe",
    title: "不安全 Rust · 章节测验",
    passPercent: 90,
    questions: [
      { id: "us-q1", type: "tf", prompt: "unsafe 不意味着代码一定有 bug，而是编译器无法保证其安全。", options: tfOptions(), answer: ["t"] },
      {
        id: "us-q2",
        type: "single",
        prompt: "unsafe 允许的操作之一是：",
        options: [
          { id: "a", text: "解引用原始指针" },
          { id: "b", text: "自动 GC" },
          { id: "c", text: "绕过所有权系统" },
          { id: "d", text: "禁用 borrow checker" },
        ],
        answer: ["a"],
      },
      { id: "us-q3", type: "tf", prompt: "调用 unsafe 函数必须在 unsafe 块或 unsafe fn 中。", options: tfOptions(), answer: ["t"] },
      { id: "us-q4", type: "tf", prompt: "原始指针（*const T / *mut T）可能为 null。", options: tfOptions(), answer: ["t"] },
      {
        id: "us-q5",
        type: "single",
        prompt: "下面哪项不是 unsafe 允许的五类操作之一？",
        options: [
          { id: "a", text: "解引用原始指针" },
          { id: "b", text: "访问或修改可变静态变量" },
          { id: "c", text: "实现 unsafe trait" },
          { id: "d", text: "绕过类型检查把任何类型强转成任何类型（无需约束）" },
        ],
        answer: ["d"],
      },
      { id: "us-q6", type: "tf", prompt: "unsafe 块应尽量小，并封装成安全 API。", options: tfOptions(), answer: ["t"] },
      { id: "us-q7", type: "tf", prompt: "在 unsafe 中也可能出现数据竞争。", options: tfOptions(), answer: ["t"] },
      {
        id: "us-q8",
        type: "single",
        prompt: "以下哪项最贴近“安全抽象”的思想？",
        options: [
          { id: "a", text: "把所有 unsafe 代码散落在各处" },
          { id: "b", text: "把 unsafe 细节隐藏在模块内部，对外提供 safe API" },
          { id: "c", text: "只要写 unsafe 就不写测试" },
          { id: "d", text: "把 unsafe 当成性能开关随便用" },
        ],
        answer: ["b"],
      },
      { id: "us-q9", type: "tf", prompt: "extern \"C\" 用于与 C ABI 交互。", options: tfOptions(), answer: ["t"] },
      { id: "us-q10", type: "tf", prompt: "static mut 访问是安全的，不需要 unsafe。", options: tfOptions(), answer: ["f"] },
      { id: "us-q11", type: "tf", prompt: "unsafe trait 表示实现者必须满足额外的不变量。", options: tfOptions(), answer: ["t"] },
      { id: "us-q12", type: "tf", prompt: "从_raw_parts_mut 等函数通常是 unsafe，因为需要调用者保证指针与长度合法。", options: tfOptions(), answer: ["t"] },
      {
        id: "us-q13",
        type: "single",
        prompt: "下面哪项更可能导致未定义行为（UB）？",
        options: [
          { id: "a", text: "对 null 原始指针解引用" },
          { id: "b", text: "对 i32 做加法" },
          { id: "c", text: "匹配一个 enum" },
          { id: "d", text: "调用 println!" },
        ],
        answer: ["a"],
      },
      { id: "us-q14", type: "tf", prompt: "UB 不一定立刻崩溃，可能表现为随机错误。", options: tfOptions(), answer: ["t"] },
      {
        id: "us-q15",
        type: "single",
        prompt: "使用 unsafe 的首要原则之一是：",
        options: [
          { id: "a", text: "能不用就不用；必须用时把范围缩到最小" },
          { id: "b", text: "优先 unsafe，safe 只用于 demo" },
          { id: "c", text: "unsafe = 更快" },
          { id: "d", text: "unsafe = 不需要文档" },
        ],
        answer: ["a"],
      },
      { id: "us-q16", type: "tf", prompt: "unsafe 可以跳过借用规则并在同一数据上同时创建多个 &mut 引用而不出问题。", options: tfOptions(), answer: ["f"] },
      { id: "us-q17", type: "tf", prompt: "把 unsafe 封装成 safe API 时，需要在文档中说明其安全前提。", options: tfOptions(), answer: ["t"] },
      {
        id: "us-q18",
        type: "single",
        prompt: "下面哪项是“调用 unsafe 函数”的正确位置？",
        options: [
          { id: "a", text: "任意地方都可以" },
          { id: "b", text: "必须在 unsafe 块或 unsafe fn 中" },
          { id: "c", text: "只能在 main 中" },
          { id: "d", text: "只能在宏中" },
        ],
        answer: ["b"],
      },
      { id: "us-q19", type: "tf", prompt: "unsafe 代码同样需要测试与审查，甚至更严格。", options: tfOptions(), answer: ["t"] },
      { id: "us-q20", type: "tf", prompt: "安全 Rust 可以调用 unsafe 块内部的代码而无需任何额外约束。", options: tfOptions(), answer: ["f"] },
    ],
  },
};
